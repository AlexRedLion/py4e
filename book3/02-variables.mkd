Variables, expresiones y sentencias
===================================

Valores y tipos
---------------

\index{valor}
\index{tipo}
\index{cadena}

Un *valor* es una de las cosas básicas que utiliza un
programa, como una letra o un número. Los valores que hemos visto hasta
ahora han sido `1`, `2`, y "¡Hola, mundo!"

Esos valores pertenecen a *tipos* diferentes:
`2` es un entero (int), y "¡Hola, mundo!" es una
*cadena* (string), que recibe ese nombre porque contiene
una "cadena" de letras. Tú (y el intérprete) podéis identificar las
cadenas porque van encerradas entre comillas.

\index{comillas}

La sentencia `print` también funciona con enteros. Vamos a
usar el comando `python` para iniciar el intérprete.

~~~~ {.python}
python
>>> print(4)
4
~~~~

Si no estás seguro de qué tipo de valor estás manejando, el intérprete
te lo puede decir.

~~~~ {.python .trinket height="160"}
>>> type(''¡Hola, mundo!)
<class 'str'>
>>> type(17)
<class 'int'>
~~~~

Not surprisingly, strings belong to the type `str` and
integers belong to the type `int`. Less obviously, numbers
with a decimal point belong to a type called `float`, because
these numbers are represented in a format called *floating
point*.

\index{type}
\index{string type}
\index{class!str}
\index{int type}
\index{class!int}
\index{float type}
\index{class!float}

~~~~ {.python .trinket height="120"}
>>> type(3.2)
<class 'float'>
~~~~

¿Qué ocurre con valores como "17" y "3.2"? Parecen números, pero van
entre comillas como las cadenas.

\index{comillas}

~~~~ {.python .trinket  height="160"}
>>> type('17')
<class 'str'>
>>> type('3.2')
<class 'str'>
~~~~

Son cadenas.

Cuando escribes un entero grande, puede que te sientas tentado a usar
comas o puntos para separarlo en grupos de tres dígitos, como en
`1,000,000` [^2]. Eso no es un entero válido en Python, pero
en cambio sí que resulta válido algo como:

~~~~ {.python .trinket height="120"}
>>> print(1,000,000)
1 0 0
~~~~

Bien, ha funcionado. ¡Pero eso no era lo que esperábamos!. Python
interpreta `1,000,000` como una secuencia de enteros
separados por comas, así que lo imprime con espacios en medio.

\index{semántico, error}
\index{error!semántico}
\index{mensaje de error}

Éste es el primer ejemplo que hemos visto de un error semántico: el
código funciona sin producir ningún mensaje de error, pero no hace su
trabajo "correctamente".

Variables
---------

\index{variable}
\index{asignación!sentencia}
\index{sentencia!asignación}

Una de las características más potentes de un lenguaje de programación
es la capacidad de manipular *variables*. Una variable es
un nombre que se refiere a un valor.

Una *sentencia de asignación* crea variables nuevas y las
da valores:

~~~~ {.python}
>>> mensaje = 'Y ahora algo completamente diferente'
>>> n = 17
>>> pi = 3.1415926535897931
~~~~

Este ejemplo hace tres asignaciones. La primera asigna una cadena a una
variable nueva llamada `mensaje`; la segunda asigna el entero
`17` a `n`; la tercera asigna el valor
(aproximado) de $\pi$ a `pi`.

Para mostrar el valor de una variable, se puede usar la sentencia print:

~~~~ {.python}
>>> print(n)
17
>>> print(pi)
3.141592653589793
~~~~

El tipo de una variable es el tipo del valor al que se refiere.

~~~~ {.python}
>>> type(mensaje)
<class 'str'>
>>> type(n)
<class 'int'>
>>> type(pi)
<class 'float'>
~~~~

Nombres de variables y palabras claves
--------------------------------------

\index{palabra clave}

Los programadores generalmente eligen nombres para sus variables que
tengan sentido y documenten para qué se usa esa variable.

Los nombres de las variables pueden ser arbitrariamente largos. Pueden
contener tanto letras como números, pero no pueden comenzar con un
número. Se pueden usar letras mayúsculas, pero es buena idea comenzar
los nombres de las variables con una letras minúscula (veremos por qué
más adelante).

El carácter guión-bajo (`_`) puede utilizarse en un nombre. A menudo se
utiliza en nombres con múltiples palabras, como en `mi_nombre` o
`velocidad_de_golondrina_sin_carga`. Los nombres de las variables pueden
comenzar con un carácter guión-bajo, pero generalmente se evita usarlo
así a menos que se esté escribiendo código para librerías que luego
utilizarán otros.

\index{guión-bajo, carácter}

Si se le da a una variable un nombre no permitido, se obtiene un error
de sintaxis:

~~~~ {.python .trinket height="450"}
>>> 76trombones = 'gran desfile'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Teorema avanzado de Zymurgy'
SyntaxError: invalid syntax
~~~~

`76trombones` es incorrecto porque comienza por un número.
`more@` es incorrecto porque contiene un carácter no
premitido, `@`. Pero, ¿qué es lo que está mal en
`class`?

Pues resulta que `class` es una de las *palabras
clave* de Python. El intérprete usa palabras clave para
reconocer la estructura del programa, y esas palabras no pueden ser
utilizadas como nombres de variables.

\index{palabra clave}

Python reserva 33 palabras claves para su propio uso:

~~~~
and       del       from      None      True
as        elif      global    nonlocal  try
assert    else      if        not       while
break     except    import    or        with
class     False     in        pass      yield
continue  finally   is        raise
def       for       lambda    return
~~~~

Puede que quieras tener esta lista a mano. Si el intérprete se queja por
el nombre de una de tus variables y no sabes por qué, comprueba si ese
nombre está en esta lista.

Sentencias
----------

Una *sentencia* es una unidad de código que el intérprete
de Python puede ejecutar. Hemos visto hasta ahora dos tipos de
sentencia: print y las asignaciones.

\index{sentencia}
\index{interactivo, modo}
\index{script, modo}

Cuando escribes una sentencia en modo interactivo, el intérprete la
ejecuta y muestra el resultado, si es que lo hay.

Un script normalmente contiene una secuencia de sentencias. Si hay más
de una sentencia, los resultados aparecen de uno en uno según se van
ejecutando las sentencias.

Por ejemplo, el script

~~~~ {.python}
print(1)
x = 2
print(x)
~~~~

produce la salida

~~~~
1
2
~~~~

La sentencia de asignación no produce ninguna salida.

Operadores y operandos
----------------------

\index{operador!aritmético}
\index{aritmético, operador}
\index{operando}
\index{expresión}

*Los operadores* son símbolos especiales que representan
cálculos, como la suma o la multiplicación. Los valores a los cuales se
aplican esos operadores reciben el nombre de *operandos*.

Los operadores `+`, `-`, , `/`, y
`\* realizan sumas, restas, multiplicaciones, divisiones y
exponenciación (elevar un número a una potencia), como se muestra en los
ejemplos siguientes:

~~~~ {.python}
20+32
hour-1
hour*60+minute
minute/60
5**2
(5+9)*(15-7)
~~~~

Ha habido un cambio en el operador de división entre Python 2.x
y Python 3.x. En Python 3.x, el resultado de esta división es un
resultado de punto flotante:

~~~~ {.python .trinket height="160"}
>>> minute = 59
>>> minute/60
0.9833333333333333
~~~~

El operador de división en Python 2.0 dividiría dos enteros y
truncar el resultado a un entero:

~~~~ {.python}
>>> minute = 59
>>> minute/60
0
~~~~

Para obtener la misma respuesta en Python 3.0 use división dividida (`//` integer).

~~~~ {.python .trinket  height="160"}
>>> minute = 59
>>> minute//60
0
~~~~

En Python 3, la división de enteros funciona mucho más como cabría esperar.
Si ingresaste la expresión en una calculadora.

\index{Python 3}
\index{Python 2}
\index{entera, división}
\index{punto-flotante, división}
\index{división!entera}
\index{división!punto-flotante}

Expresiones
-----------

Una *expresión* es una combinación de valores, variables
y operadores. Un valor por si mismo se considera una expresión, y
también lo es una variable, así que las siguientes expresiones son todas
válidas (asumiendo que la variable `x` tenga un valor
asignado):

\index{expresión}
\index{evaluar}

~~~~ {.python}
17
x
x + 17
~~~~

Si escribes una expresión en modo interactivo, el intérprete la
*evalúa* y muestra el resultado:

~~~~ {.python}
>>> 1 + 1
2
~~~~

Sin embargo, en un script, ¡una expresión por si misma no hace nada!
Esto a menudo puede producir confusión entre los principiantes.

**Exercise 1: Escribe las siguientes sentencias en el intérprete de Python
para comprobar qué hacen:**

~~~~ {.python}
5
x = 5
x + 1
~~~~

Orden de las operaciones
------------------------

\index{orden de operaciones}
\index{reglas de precedencia}
\index{PEMDSR}

Cuando en una expresión aparece más de un operador, el orden de
evaluación depende de las *reglas de precedencia*. Para
los operadores matemáticos, Python sigue las convenciones matemáticas.
El acrónimo *PEMDSR* resulta útil para recordar esas
reglas:

\index{paréntesis!invalidar precedencia}

-   Los *P*aréntesis tienen el nivel superior de
    precedencia, y pueden usarse para forzar a que una expresión sea
    evaluada en el orden que se quiera. Dado que las expresiones entre
    paréntesis son evaluadas primero, `2 \* (3-1)` es 4, y
    `(1+1)\*\*(5-2)` es 8. Se pueden usar también paréntesis
    para hacer una expresión más sencilla de leer, incluso si el
    resultado de la misma no varía por ello, como en `(minuto \*
    100) / 60`.

-   La *E*xponenciación (elevar un número a una potencia)
    tiene el siguiente nivel más alto de precedencia, de modo que
    `2\*\*1+1` es 3, no 4, y `3\*1\*\*3` es 3,
    no 27.

-   La *M*ultiplicación y la *D*ivisión
    tienen la misma precedencia, que es superior a la de la
    *S*uma y la *R*esta, que también
    tienen entre si el mismo nivel de precedencia. Así que
    `2\*3-1` es 5, no 4, y `6+4/2` es 8, no 5.

-   Los operadores con igual precedencia son evaluados de izquierda
    a derecha. Así que la expresión `5-3-1` es 1 y no 3, ya
    que `5-3` se evalúa antes, y después se resta
    `1` de `2`.

En caso de duda, añade siempre paréntesis a tus expresiones para
asegurarte de que las operaciones se realizan en el orden que tú
quieres.

Operador módulo
---------------

\index{módulo, operador}
\index{operador!módulo}

El *operador módulo* trabaja con enteros y obtiene el
resto de la operación consistente en dividir el primer operando por el
segundo. En Python, el operador módulo es un signo de porcentaje (`%`).
La sintaxis es la misma que se usa para los demás operadores:

~~~~ {.python .trinket height="240"}
>>> quotient = 7 // 3
>>> print(quotient)
2
>>> remainder = 7 % 3
>>> print(remainder)
1
~~~~

Así que 7 dividido por 3 es 2 y nos sobra 1.

El operador módulo resulta ser sorprendentemente útil. Por ejemplo,
puedes comprobar si un número es divisible por otro—si `x %
y` es cero, entonces `x` es divisible por
`y`.

\index{divisibilidad}

También se puede extraer el dígito más a la derecha de los que componen
un número. Por ejemplo, `x % 10` obtiene el dígito que está
más a la derecha de `x` (en base 10). De forma similar,
`x % 100` obtiene los dos últimos dígitos.

Operaciones con cadenas
-----------------------

\index{cadena!operación}
\index{operador!cadena}

El operador `+` funciona con las cadenas, pero no realiza una
suma en el sentido matemático. En vez de eso, realiza una
*concatenación*, que quiere decir que une ambas cadenas,
enlazando el final de la primera con el principio de la segunda. Por
ejemplo:

\index{concatenación}

~~~~ {.python}
>>> primero = 10
>>> segundo = 15
>>> print(primero+segundo)
25
>>> primero = '100'
>>> segundo = '150'
>>> print(primero + segundo)
100150
~~~~

La salida de este programa es `100150`.

El operador `*` también trabaja con cadenas multiplicando el contenido
de una cadena por un entero. Por ejemplo:

~~~~ {.python}
>>> primero = 'Test '
>>> second = 3
>>> print(primero * second)
Test Test Test
~~~~

Petición de información al usuario
----------------------------------

\index{entrada desde teclado}

A veces necesitaremos que sea el usuario quien nos proporcione el valor
para una variable, a través del teclado. Python proporciona una función
interna llamada `raw_input` que recibe la entrada desde el teclado[^5].
Cuando se llama a esa función, el programa se detiene y espera a que el
usuario escriba algo. Cuando el usuario pulsa `Retorno` o
`Intro`, el programa continúa y `raw_input` devuelve como una
cadena aquello que el usuario escribió.

\index{Python 3.0}
\index{raw}
\index{función!raw}

~~~~ {.python}
>>> entrada = input()
Cualquier cosa ridícula
>>> print(entrada)
Cualquier cosa ridícula
~~~~

Antes de recibir cualquier dato desde el usuario, es buena idea escribir
un mensaje explicándole qué debe introducir. Se puede pasar una cadena a
`raw_input`, que será mostrada al usuario antes de que el programa se
detenga para recibir su entrada:

\index{indicador}

~~~~ {.python}
>>> nombre = input('¿Cómo te llamas?\n')
¿Cómo te llamas?
Chuck
>>> print(nombre)
Chuck
~~~~

La secuencia `\n` al final del mensaje representa un
*newline*, que es un carácter especial que provoca un
salto de línea. Por eso la entrada del usuario aparece debajo de nuestro
mensaje.

\index{salto de línea}

Si esperas que el usuario escriba un entero, puedes intentar convertir
el valor de retorno a `int` usando la función
`int()`:

~~~~ {.python}
>>> prompt = '¿Cual.... es la velocidad de vuelo de una golondrina sin carga?\n'
>>> velocidad = input(prompt)
¿Cual.... es la velocidad de vuelo de una golondrina sin carga?
17
>>> int(velocidad)
17
>>> int(velocidad) + 5
22
~~~~

Pero si el usuario escribe algo que no sea una cadena de dígitos,
obtendrás un error:

~~~~ {.python}
>>> velocidad = input(prompt)
¿Cual.... es la velocidad de vuelo de una golondrina sin carga?
¿Te refieres a una golondrina africana o a una europea?
>>> int(velocidad)
ValueError: invalid literal for int()
~~~~

Veremos cómo controlar este tipo de errores más adelante.

\index{ValueError}
\index{exception!ValueError}

Comentarios
-----------

\index{comentarios}

A medida que los programas se van volviendo más grandes y complicados,
se vuelven más difíciles de leer. Los lenguajes formales son densos, y a
menudo es complicado mirar un trozo de código e imaginarse qué es lo que
hace, o por qué.

Por eso es buena idea añadir notas a tus programas, para explicar en un
lenguaje normal qué es lo que el programa está haciendo. Estas notas
reciben el nombre de *comentarios*, y en Python comienzan
con el símbolo `#`:

~~~~ {.python}
# calcula el porcentaje de hora transcurrido
porcentaje = (minuto * 100) / 60
~~~~

En este caso, el comentario aparece como una línea completa. Pero
también puedes poner comentarios al final de una línea

~~~~ {.python}
porcentaje = (minuto * 100) / 60     # porcentaje de una hora
~~~~

Todo lo que va desde `\#` hasta el final de la línea es
ignorado—no afecta para nada al programa.

Las comentarios son más útiles cuando documentan características del
código que no resultan obvias. Es razonable asumir que el lector puede
descifrar *qué* es lo que el código hace; es mucho más útil explicarle
*por qué*.

Este comentario es redundante con el código e inútil:

~~~~ {.python}
v = 5     # asigna 5 a v
~~~~

Este comentario contiene información útil que no está en el código:

~~~~ {.python}
v = 5     # velocidad en metros/segundo.
~~~~

Elegir nombres adecuados para las variables puede reducir la necesidad
de comentarios, pero los nombres largos también pueden ocasionar que las
expresiones complejas sean difíciles de leer, así que hay que conseguir
una solución de compromiso.

Choosing mnemonic variable names
--------------------------------

\index{mnemonic}

As long as you follow the simple rules of variable naming, and avoid
reserved words, you have a lot of choice when you name your variables.
In the beginning, this choice can be confusing both when you read a
program and when you write your own programs. For example, the following
three programs are identical in terms of what they accomplish, but very
different when you read them and try to understand them.

~~~~ {.python}
a = 35.0
b = 12.50
c = a * b
print(c)
~~~~

~~~~ {.python}
hours = 35.0
rate = 12.50
pay = hours * rate
print(pay)
~~~~

~~~~ {.python}
x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print(x1q3p9afd)
~~~~

The Python interpreter sees all three of these programs as *exactly the
same* but humans see and understand these programs quite differently.
Humans will most quickly understand the *intent* of the
second program because the programmer has chosen variable names that
reflect their intent regarding what data will be stored in each
variable.

We call these wisely chosen variable names "mnemonic variable names".
The word *mnemonic*^[See <https://en.wikipedia.org/wiki/Mnemonic> for an extended
description of the word "mnemonic".] means "memory aid". We choose mnemonic variable
names to help us remember why we created the variable in the first
place.

While this all sounds great, and it is a very good idea to use mnemonic
variable names, mnemonic variable names can get in the way of a
beginning programmer's ability to parse and understand code. This is
because beginning programmers have not yet memorized the reserved words
(there are only 33 of them) and sometimes variables with names that are
too descriptive start to look like part of the language and not just
well-chosen variable names.

Take a quick look at the following Python sample code which loops
through some data. We will cover loops soon, but for now try to just
puzzle through what this means:

~~~~ {.python}
for word in words:
    print(word)
~~~~

What is happening here? Which of the tokens (for, word, in, etc.) are
reserved words and which are just variable names? Does Python understand
at a fundamental level the notion of words? Beginning programmers have
trouble separating what parts of the code *must* be the same as this
example and what parts of the code are simply choices made by the
programmer.

The following code is equivalent to the above code:

~~~~ {.python}
for slice in pizza:
    print(slice)
~~~~

It is easier for the beginning programmer to look at this code and know
which parts are reserved words defined by Python and which parts are
simply variable names chosen by the programmer. It is pretty clear that
Python has no fundamental understanding of pizza and slices and the fact
that a pizza consists of a set of one or more slices.

But if our program is truly about reading data and looking for words in
the data, `pizza` and `slice` are very un-mnemonic
variable names. Choosing them as variable names distracts from the
meaning of the program.

After a pretty short period of time, you will know the most common
reserved words and you will start to see the reserved words jumping out
at you:

<pre>
<b>for</b> word <b>in</b> words<b>:</b>
    <b>print</b>(word)
</pre>

The parts of the code that are defined by Python (`for`,
`in`, `print`, and `:`) are in bold and
the programmer-chosen variables (`word` and
`words`) are not in bold. Many text editors are aware of
Python syntax and will color reserved words differently to give you
clues to keep your variables and reserved words separate. After a while
you will begin to read Python and quickly determine what is a variable
and what is a reserved word.

Debugging
---------

\index{debugging}

At this point, the syntax error you are most likely to make is an
illegal variable name, like `class` and `yield`,
which are keywords, or `odd~job` and `US$`, which contain illegal
characters.

\index{syntax error}
\index{error!syntax}

If you put a space in a variable name, Python thinks it is two operands
without an operator:

~~~~ {.python}
>>> bad name = 5
SyntaxError: invalid syntax
~~~~

~~~~ {.python}
>>> month = 09
  File "<stdin>", line 1
    month = 09
             ^
SyntaxError: invalid token
~~~~

For syntax errors, the error messages don't help much. The most common
messages are `SyntaxError: invalid syntax` and
`SyntaxError: invalid token`, neither of which is very
informative.

\index{error message}
\index{use before def}
\index{exception}
\index{runtime error}
\index{error!runtime}

The runtime error you are most likely to make is a "use before def;"
that is, trying to use a variable before you have assigned a value. This
can happen if you spell a variable name wrong:

~~~~ {.python}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
~~~~

Variables names are case sensitive, so `LaTeX` is not the
same as `latex`.

\index{case-sensitivity, variable names}
\index{semantic error}
\index{error!semantic}

At this point, the most likely cause of a semantic error is the order of
operations. For example, to evaluate $1/2\pi$, you might be
tempted to write

~~~~ {.python}
>>> 1.0 / 2.0 * pi
~~~~

But the division happens first, so you would get $\pi / 2$, which is not
the same thing! There is no way for Python to know what you meant to
write, so in this case you don't get an error message; you just get the
wrong answer.

\index{order of operations}

Glossary
--------

assignment
:   A statement that assigns a value to a variable.
\index{assignment}

concatenate
:   To join two operands end to end.
\index{concatenation}

comment
:   Information in a program that is meant for other programmers (or
    anyone reading the source code) and has no effect on the execution
    of the program.
\index{comment}

evaluate
:   To simplify an expression by performing the operations in order to
    yield a single value.

expression
:   A combination of variables, operators, and values that represents a
    single result value.
\index{expression}

floating point
:   A type that represents numbers with fractional parts.
\index{floating-point}

integer
:   A type that represents whole numbers.
\index{integer}

keyword
:   A reserved word that is used by the compiler to parse a program; you
    cannot use keywords like `if`, `def`, and
    `while` as variable names.
\index{keyword}

mnemonic
:   A memory aid. We often give variables mnemonic names to help us
    remember what is stored in the variable.
\index{mnemonic}

modulus operator
:   An operator, denoted with a percent sign (`%`), that
    works on integers and yields the remainder when one number is
    divided by another.
\index{modulus operator}
\index{operator!modulus}

operand
:   One of the values on which an operator operates.
\index{operand}

operator
:   A special symbol that represents a simple computation like addition,
    multiplication, or string concatenation.
\index{operator}

rules of precedence
:   The set of rules governing the order in which expressions involving
    multiple operators and operands are evaluated.
\index{rules of precedence}
\index{precedence}

statement
:   A section of code that represents a command or action. So far, the
    statements we have seen are assignments and print expression statement.
\index{statement}

string
:   A type that represents sequences of characters.
\index{string}

type
:   A category of values. The types we have seen so far are integers
    (type `int`), floating-point numbers (type
    `float`), and strings (type `str`).
\index{type}

value
:   One of the basic units of data, like a number or string, that a
    program manipulates.
\index{value}

variable
:   A name that refers to a value.
\index{variable}

Exercises
---------

**Exercise 2: Write a program that uses `input` to prompt a user for
their name and then welcomes them.**

~~~~
Enter your name: Chuck
Hello Chuck
~~~~

**Exercise 3: Write a program to prompt the user for hours and rate per
hour to compute gross pay.**

~~~~
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
~~~~

We won't worry about making sure our pay has exactly two digits after
the decimal place for now. If you want, you can play with the built-in
Python `round` function to properly round the resulting pay
to two decimal places.

**Exercise 4: Assume that we execute the following assignment statements:**

~~~~
width = 17
height = 12.0
~~~~

For each of the following expressions, write the value of the expression
and the type (of the value of the expression).

1.  `width//2`

2.  `width/2.0`

3.  `height/3`

4.  `1 + 2 * 5`

Use the Python interpreter to check your answers.

**Exercise 5: Write a program which prompts the user for a Celsius
temperature, convert the temperature to Fahrenheit, and print out the
converted temperature.**

