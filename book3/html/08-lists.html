<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>-</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="http://thisisdallas.github.io/Simple-Grid/simpleGrid.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="listas">Listas</h1>
<p> </p>
<h2 id="una-lista-es-una-secuencia">Una lista es una secuencia</h2>
<p>Así como una cadena, una <em>lista</em> es una secuencia de valores. En una cadena, los valores son caracteres; en una lista, pueden ser cualquier tipo. Los valores en una lista son llamados <em>elementos</em> o a veces <em>ítems</em>.</p>
<p>  </p>
<p>Hay varias formas de crear una nueva lista; la más simple es encerrar los elementos en corchetes (“[" y "]”):</p>
<pre class="python"><code>[10, 20, 30, 40]
[&#39;rana crujiente&#39;, &#39;vejiga de carnero&#39;, &#39;vómito de alondra&#39;]</code></pre>
<p>El primer ejemplo es una lista de 4 enteros. La segunda es una lista de tres cadenas. Los elementos de una lista no tienen que ser del mismo tipo. La siguiente lista contiene una cadena, un flotante, un entero, y (¡mira!) otra lista:</p>
<pre class="python"><code>[&#39;spam&#39;, 2.0, 5, [10, 20]]</code></pre>
<p>Una lista dentro de otra lista está <em>anidada</em>.</p>
<p> </p>
<p>Una lista que no contiene elementos es llamada una lista vacía; puedes crear una con corchetes vacíos, <code>[]</code>.</p>
<p> </p>
<p>Como puedes ver, puedes asignar los valores de una lista a variables:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; quesos = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;]
&gt;&gt;&gt; numeros = [17, 123]
&gt;&gt;&gt; vacia = []
&gt;&gt;&gt; print(quesos, numeros, vacia)
[&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] [17, 123] []</code></pre>
<p></p>
<h2 id="las-listas-son-mutables">Las listas son mutables</h2>
<p>     </p>
<p>La sintaxis para accesar elementos de una lista es la misma que para accesar los caracteres de una cadena: el operador corchete. La expresión dentro de los corchetes especifíca el índice. Recordemos que los índices empiezan en 0:</p>
<pre class="python"><code>&gt;&gt;&gt; print(quesos[0])
Cheddar</code></pre>
<p>A diferencia de las cadenas, las listas son mutables porque pueden cambiar el orden de los elementos en una lista o reasignar un elemento en una lista. Cuando el operador corchete aparece en el lado izquierdo de una asignación, éste identifica el elemento de la lista que será asignado.</p>
<p></p>
<pre class="python trinket"><code>&gt;&gt;&gt; numeros = [17, 123]
&gt;&gt;&gt; numeros[1] = 5
&gt;&gt;&gt; print(numeros)
[17, 5]</code></pre>
<p>El elemento en la posición uno de <code>numeros</code>, el cual solía ser 123, es ahora 5.</p>
<p> </p>
<p>Puedes pensar en una lista como una relación entre índices y elementos. Esta relación es llamada <em>mapeo</em>; cada índice “mapea a” uno de los elementos.</p>
<p> </p>
<p>Los índices en una lista funcionan de la misma manera que los índices de una cadena:</p>
<ul>
<li><p>Cualquier forma de entero puede ser utilizada como índice.</p></li>
<li><p>Si tratas de leer o escribir un elemento que no existe, obtendrás un <code>IndexError</code>.</p></li>
</ul>
<p> </p>
<ul>
<li>Si un índice tiene un valor negativo, éste cuenta hacia atrás desde el final de la lista.</li>
</ul>
<p>    </p>
<p>El operador <code>in</code> funciona también en listas.</p>
<pre class="python trinket"><code>&gt;&gt;&gt; quesos = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;]
&gt;&gt;&gt; &#39;Edam&#39; in quesos
True
&gt;&gt;&gt; &#39;Brie&#39; in quesos
False</code></pre>
<h2 id="recorriendo-una-lista">Recorriendo una lista</h2>
<p>    </p>
<p>La forma más común de recorrer los elementos de una lista es con un bucle <code>for</code>. La sintaxis es la misma que para las cadenas:</p>
<pre class="python"><code>for queso in quesos:
    print(queso)</code></pre>
<p>Esto funciona bien si solamente necesitas leer los elementos de la lista. Pero si quieres escribir o actualizar los elementos, necesitas los índices. Una forma común de hacer eso es combinando las funciones <code>range</code> y <code>len</code>:</p>
<p> </p>
<pre class="python"><code>for i in range(len(numeros)):
    numeros[i] = numeros[i] * 2</code></pre>
<p>Este bucle recorre la lista y actualiza cada elemento. <code>len</code> regresa el número de elementos en una lista. <code>range</code> regresa una lista de índices desde 0 hasta <span class="math inline"><em>n</em> − 1</span>, donde <span class="math inline"><em>n</em></span> es la longitud de la lista. Cada vez que pasa a través del recorrido, <code>i</code> obtiene el índice del siguiente elemento. La sentencia de asignación dentro del bucle utiliza <code>i</code> para leer el valor original del elemento y asignar un nuevo valor.</p>
<p> </p>
<p>Un bucle <code>for</code> a través de una lista vacía nunca ejecuta el código contenido en el cuerpo:</p>
<pre class="python"><code>for x in vacia:
    print(&#39;Esto nunca sucede.&#39;)</code></pre>
<p>Aunque una lista puede contener otra lista, las listas anidadas siguen contando como un solo elemento. El tamaño de esta lista es cuatro:</p>
<p> </p>
<pre class="python"><code>[&#39;spam&#39;, 1, [&#39;Brie&#39;, &#39;Roquefort&#39;, &#39;Pol le Veq&#39;], [1, 2, 3]]</code></pre>
<h2 id="operaciones-de-listas">Operaciones de listas</h2>
<p></p>
<p>El operador <code>+</code> concatena listas:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; print(c)
[1, 2, 3, 4, 5, 6]</code></pre>
<p>De igual forma, el operador <code>*</code> repite una lista un determinado número de veces:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]</code></pre>
<p>En el primer ejemplo se repite cuatro veces. En el segundo ejemplo se repite la lista tres veces.</p>
<h2 id="rebanado-de-listas">Rebanado de listas</h2>
<p>    </p>
<p>El operador de rebanado también funciona en listas:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
&gt;&gt;&gt; t[1:3]
[&#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t[:4]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
&gt;&gt;&gt; t[3:]
[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code></pre>
<p>Si omites el primer índice, el rebanado comienza desde el inicio de la lista. Si omites el segundo, el rebanado se va hasta el final. Así que si omites ambos, el rebanado es una copia de la lista completa.</p>
<p>  </p>
<pre class="python"><code>&gt;&gt;&gt; t[:]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code></pre>
<p>Como las listas son mutables, a veces es útil hacer una copia antes de hacer operaciones que doblan, pegan, o cortan listas.</p>
<p></p>
<p>Un operador de rebanado al lado izquierdo de una asignación puede actualizar múltiples elementos:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
&gt;&gt;&gt; t[1:3] = [&#39;x&#39;, &#39;y&#39;]
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;x&#39;, &#39;y&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code></pre>
<h2 id="métodos-de-listas">Métodos de listas</h2>
<p> </p>
<p>Python provee métodos que operan en listas. Por ejemplo, <code>append</code> agrega un nuevo elemento al final de una lista:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t.append(&#39;d&#39;)
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre>
<p><code>extend</code> toma una lista como argumento y agrega todos los elementos:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t2 = [&#39;d&#39;, &#39;e&#39;]
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; print(t1)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre>
<p>Este ejemplo deja <code>t2</code> sin modificar.</p>
<p><code>sort</code> ordena los elementos de la lista de menor a mayor:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;d&#39;, &#39;c&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;]
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre>
<p>La mayoría de métodos no regresan nada; modifican la lista y regresan <code>None</code>. Si accidentalmentes escribes <code>t = t.sort()</code>, vas a decepcionarte con el resultado.</p>
<p>   </p>
<h2 id="eliminando-elementos">Eliminando elementos</h2>
<p> </p>
<p>Hay varias formas de eliminar elementos de una lista. Si sabes el índice del elemento que quieres, puedes usar <code>pop</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;c&#39;]
&gt;&gt;&gt; print(x)
b</code></pre>
<p><code>pop</code> modifica la lista y regresa el elemento que fue removido. Si no provees un índice, la función elimina y retorna el último elemento.</p>
<p>Si no necesitas el valor removido, puedes usar el operador <code>del</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;c&#39;]</code></pre>
<p>Si sabes qué elemento quieres remover (pero no sabes el índice), puedes usar <code>remove</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t.remove(&#39;b&#39;)
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;c&#39;]</code></pre>
<p>El valor de retorno de <code>remove</code> es <code>None</code>.</p>
<p> </p>
<p>Para remover más de un elemento, puedes usar <code>del</code> con un índice de rebanado:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;f&#39;]</code></pre>
<p>Como siempre, el rebanado selecciona todos los elementos hasta, pero excluyendo, el segundo índice.</p>
<h2 id="listas-y-funciones">Listas y funciones</h2>
<p>Hay un cierto número funciones internas que pueden ser utilizadas en las listas que te permiten mirar rápidamente a través de una lista sin escribir tus propios bucles:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; nums = [3, 41, 12, 9, 74, 15]
&gt;&gt;&gt; print(len(nums))
6
&gt;&gt;&gt; print(max(nums))
74
&gt;&gt;&gt; print(min(nums))
3
&gt;&gt;&gt; print(sum(nums))
154
&gt;&gt;&gt; print(sum(nums)/len(nums))
25</code></pre>
<p>La función <code>sum()</code> solamente funciona cuando los elementos de la lista son números. Las otras funciones (<code>max()</code>, <code>len()</code>, etc.) funcionan con listas de cadenas y otros tipos que pueden ser comparados entre sí.</p>
<p>Podríamos reescribir un programa anterior que calculaba el promedio de una lista de números ingresados por el usuario utilizando una lista.</p>
<p>Primero, el programa para calcular un promedio sin una lista:</p>
<pre class="python"><code>total = 0
contador = 0
while (True):
    inp = input(&#39;Ingresa un número: &#39;)
    if inp == &#39;fin&#39;: break
    valor = float(inp)
    total = total + valor
    contador = contador + 1

promedio = total / contador
print(&#39;Promedio:&#39;, promedio)

# Code: http://www.py4e.com/code3/avenum.py</code></pre>
<p>En este programa, tenemos las variables <code>contador</code> y <code>total</code> para almacenar la cantidad y el total actual de los números del usuario según el usuario va ingresando los números repetidamente.</p>
<p>Podríamos simplemente recordar cada número como el número lo ingresó, y utilizar funciones internas para calcular la suma y el total de números al final.</p>
<pre class="python"><code>numlista = list()
while (True):
    inp = input(&#39;Ingresa un número: &#39;)
    if inp == &#39;fin&#39;: break
    valor = float(inp)
    numlista.append(valor)

promedio = sum(numlista) / len(numlista)
print(&#39;Promedio:&#39;, promedio)

# Code: http://www.py4e.com/code3/avelist.py</code></pre>
<p>Creamos una lista vacía antes de que comience el bucle, y luego cada vez que tengamos un número, lo agregamos a la lista. Al final del programa, simplemente calculamos la suma de los números en la lista y la dividimos por el total de números en la lista para obtener el promedio.</p>
<h2 id="listas-y-cadenas">Listas y cadenas</h2>
<p>  </p>
<p>Una cadena es una secuencia de caracteres y una lista es una secuencia de valores, pero una lista de caracteres no es lo mismo que una cadena. Para convertir una cadena en una lista de caracteres, puedes usar <code>list</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; s = &#39;spam&#39;
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; print(t)
[&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;m&#39;]</code></pre>
<p>Debido a que <code>list</code> es el nombre de una función interna, debes evitar usarla como un nombre de variable. Yo trato de evitar también la letra “l” porque se parece mucho al número “1”. Así que por eso utilizo “t”.</p>
<p>La función <code>list</code> divide una cadena en letras individuales. Si quieres dividir una cadena en palabras, puedes utilizar el método <code>split</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; s = &#39;suspirando por los fiordos&#39;
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; print(t)
[&#39;suspirando&#39;, &#39;por&#39;, &#39;los&#39;, &#39;fiordos&#39;]
&gt;&gt;&gt; print(t[2])
the</code></pre>
<p>Una vez que hayas utilizado <code>split</code> para dividir una cadena en una lista de palabras, puedes utilizar el operador índice (corchetes) para ver una palabra en particular en la lista.</p>
<p>Puedes llamar <code>split</code> con un argumento opcional llamado <em>delimitador</em> que especifica qué caracteres usar para delimitar las palabras. El siguiente ejemplo utiliza un guión medio como delimitador:</p>
<p>  </p>
<pre class="python trinket"><code>&gt;&gt;&gt; s = &#39;spam-spam-spam&#39;
&gt;&gt;&gt; delimiter = &#39;-&#39;
&gt;&gt;&gt; s.split(delimiter)
[&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;]</code></pre>
<p><code>join</code> es el inverso de <code>split</code>. Este toma una lista de cadenas y concatena los elementos. <code>join</code> es un método de cadenas, así que tienes que invocarlo en el delimitador y pasar la lista como un parámetro:</p>
<p>  </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;suspirando&#39;, &#39;por&#39;, &#39;los&#39;, &#39;fiordos&#39;]
&gt;&gt;&gt; delimiter = &#39; &#39;
&gt;&gt;&gt; delimiter.join(t)
&#39;suspirando por los fiordos&#39;</code></pre>
<p>En este caso el delimitador es un caracter de espacio, así que <code>join</code> agrega un espacio entre las palabras. Para concatenar cadenas sin espacios, puedes usar la cadena vacía, "", como delimitador.</p>
<p> </p>
<h2 id="analizando-líneas">Analizando líneas</h2>
<p>Normalmente cuando estamos leyendo un archivo queremos hacer algo con las líneas que no sea solamente imprimir las líneas como son. Frecuentemente queremos encontrar las “líneas interesantes” y después <em>analizar</em> la línea para encontrar alguna “parte interesante” en la línea. ¿Qué tal si quisiéramos imprimir el día de la semana de las líneas que comienzan con “From”?</p>
<pre><code>From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008</code></pre>
<p>El método <code>split</code> es muy efectivo cuando nos encontramos este tipo de problemas. Podemos escribir un pequeño programa que busca líneas donde la línea comienza con “From”, <code>split</code> (dividir) esas líneas, y finalmente imprimir la tercer palabra de la línea:</p>
<pre class="python"><code>man_a = open(&#39;mbox-short.txt&#39;)
for linea in man_a:
    linea = linea.rstrip()
    if not linea.startswith(&#39;From &#39;): continue
    palabras = linea.split()
    print(palabras[2])

# Code: http://www.py4e.com/code3/search5.py</code></pre>
<p>El programa produce lo siguiente:</p>
<pre><code>Sat
Fri
Fri
Fri
...</code></pre>
<p>Más tarde, aprenderemos técnicas muy sofisticadas para obtener las líneas que queremos para trajar sobre ellas y cómo sacar el fragmento exacto de información que estamos buscando.</p>
<h2 id="objetos-y-valores">Objetos y valores</h2>
<p> </p>
<p>Si ejecutamos las siguientes sentencias de asignación:</p>
<pre class="python"><code>a = &#39;banana&#39;
b = &#39;banana&#39;</code></pre>
<p>sabemos que ambos <code>a</code> y <code>b</code> se refieren a una cadena, pero no sabemos si se refieren o apuntan a la <em>misma</em> cadena. Hay dos estados posibles:</p>
<p></p>
<figure>
<img src="../images/list1.svg" alt="" /><figcaption>Variables y objetos</figcaption>
</figure>
<p>Por un lado, <code>a</code> y <code>b</code> se refieren a dos objetos diferentes que tienen el mismo valor. Por otro lado, apuntan al mismo objeto.</p>
<p> </p>
<p>Para revisar si dos variables apuntan al mismo objeto, puedes utilizar el operador <code>is</code>.</p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = &#39;banana&#39;
&gt;&gt;&gt; b = &#39;banana&#39;
&gt;&gt;&gt; a is b
True</code></pre>
<p>En este ejemplo, Python solamente creó un objeto de cadena, y ambos <code>a</code> y <code>b</code> apuntan a él.</p>
<p>Pero cuando creas dos listas, obtienes dos objetos diferentes:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False</code></pre>
<p>En este caso podríamos decir que las dos listas son <em>equivalentes</em>, porque tienen los mismos elementos, pero no <em>idénticas</em>, porque no son el mismo objeto. Si dos objetos son idénticos, son también equivalentes, pero si son equivalentes, no son necesariamente idénticos.</p>
<p> </p>
<p>Hasta ahora, hemos estado usando “objeto” y “valor” de forma intercambiable, pero es más preciso decir que un objeto tiene un valor. Si ejecutas <code>a = [1,2,3]</code>, <code>a</code> se refiere a una lista de objetos cuyo valor es una secuencia particular de elementos. Si otra lista tiene los mismos elementos, diríamos que tiene el mismo valor.</p>
<p> </p>
<h2 id="alias">Alias</h2>
<p> </p>
<p>Si <code>a</code> se refiere a un objecto y tu asignas<code>b = a</code>, entonces ambas variables se refieren al mismo objeto:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True</code></pre>
<p>La asociación de una variable a un objeto es llamada una <em>referencia</em>. En este ejemplo, hay dos referencias al mismo objeto.</p>
<p></p>
<p>Un objeto con más de una referencia tiene más de un nombre, así que decimos que el objeto es un <em>alias</em>.</p>
<p></p>
<p>Si el alias del objeto es mutable, los cambios hechos a un alias afectan al otro:</p>
<pre class="python"><code>&gt;&gt;&gt; b[0] = 17
&gt;&gt;&gt; print(a)
[17, 2, 3]</code></pre>
<p>Aunque este comportamiento puede ser útil, es propenso a errores. En general, es más seguro evitar usar alias cuando estás trabajando con objetos mutables.</p>
<p></p>
<p>Para objetos inmutables como cadenas, los alias no son un problema realmente. En este ejemplo:</p>
<pre class="python"><code>a = &#39;banana&#39;
b = &#39;banana&#39;</code></pre>
<p>casi nunca hay diferencia si <code>a</code> y <code>b</code> apuntan a la misma cadena o no.</p>
<h2 id="listas-como-argumentos">Listas como argumentos</h2>
<p>    </p>
<p>Cuando pasas una lista a una función, la función obtiene un apuntador a la lista. Si la función modifica un parámetro de la lista, el código que ha llamado la función también verá el cambio. Por ejemplo, <code>remover_primero</code> elimina el primer elemento de una lista:</p>
<pre class="python"><code>def remover_primero(t):
    del t[0]</code></pre>
<p>Aquí está el ejemplo de cómo se usa:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; letras = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; remover_primero(letras)
&gt;&gt;&gt; print(letras)
[&#39;b&#39;, &#39;c&#39;]</code></pre>
<p>El parámetro <code>t</code> y la variable <code>letras</code> son alias para el mismo objeto.</p>
<p>Es importante distinguir entre operaciones que modifican listas y operaciones que crean nuevas listas. Por ejemplo, el método <code>append</code> modifica una lista, pero el operador <code>+</code> crea una nueva lista:</p>
<p>   </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; print(t1)
[1, 2, 3]
&gt;&gt;&gt; print(t2)
None

&gt;&gt;&gt; t3 = t1 + [3]
&gt;&gt;&gt; print(t3)
[1, 2, 3]
&gt;&gt;&gt; t2 is t3
False</code></pre>
<p>Esta diferencia es importante cuando escribes funciones que no están destinadas a modificar listas. Por ejemplo, esta función <em>no</em> elimina el primer elemento de una lista:</p>
<pre class="python"><code>def mal_eliminar_primero(t):
    t = t[1:]              # ¡EQUIVOCADO!</code></pre>
<p>El operador de rebanado crea una nueva lista y el asignamiento hace que <code>t</code> apunte a la lista, pero nada de esto tiene efecto en la lista que fue pasada como argumento.</p>
<p> </p>
<p>Una alternativa es escribir una función que cree y regrese una nueva lista. Por ejemplo, <code>cola</code> regresa todo excepto el primer elemento de una lista:</p>
<pre class="python"><code>def cola(t):
    return t[1:]</code></pre>
<p>Esta función deja la lista original sin modificar. Aquí está como es que se usa:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; letras = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; resto = cola(letras)
&gt;&gt;&gt; print(resto)
[&#39;b&#39;, &#39;c&#39;]</code></pre>
<p>**Ejercicio 1: Escribe una función llamada <code>recortar</code> que toma una lista y la modifica, removiendo el primer y último elemento, y regresa <code>None</code>. Después escribe una función llamada <code>medio</code> que toma una lista y regresa una nueva lista que contiene todo excepto el primero y último elementos.</p>
<h2 id="depuración">Depuración</h2>
<p></p>
<p>El uso descuidado de listas (y otros objetos mutables) puede llevar a largas horas de depuración. Aquí están algumos de los errores más comunes y las formas de evitarlos:</p>
<ol type="1">
<li><p>No olvides que la mayoría de métodos de listas modifican el argumento y regresan <code>None</code>. Esto es lo opuesto a los métodos de cadenas, que regresan una nueva cadena y dejan la original sin modificar.</p>
<p>Si estás acostumbrado a escribir código de cadenas como este:</p>
<pre class="python"><code>palabra = palabra.strip()</code></pre>
<p>Estás propenso a escribir código de listas como este:</p>
<pre class="python"><code>t = t.sort()           # ¡EQUIVOCADO!</code></pre>
<p> </p>
<p>Debido a que <code>sort</code> regresa <code>None</code>, la siguiente operación que hagas con <code>t</code> es probable que falle.</p>
<p>Antes de usar métodos y operadores de listas, deberías leer la documentación cuidadosamente y después probarlos en modo interactivo. Los métodos y operadores que las listas comparten con otras secuencias (como cadenas) están documentados en:</p>
<p><a href="https://docs.python.org/library/stdtypes.html#common-sequence-operations">docs.python.org/library/stdtypes.html#common-sequence-operations</a></p>
<p>Los métodos y operadores que solamente aplican a secuencias mutables están documentados en:</p>
<p><a href="https://docs.python.org/library/stdtypes.html#mutable-sequence-types">docs.python.org/library/stdtypes.html#mutable-sequence-types</a></p></li>
<li><p>Elige un estilo y apégate a él.</p>
<p></p>
<p>Parte del problema con listas es que hay demasiadas formas de hacer las cosas. Por ejemplo, para remover un elemento de una lista, puedes utilizar <code>pop</code>, <code>remove</code>, <code>del</code>, o incluso una asignación por rebanado.</p>
<p>Para agregar un elemento, puedes utilizar el método <code>append</code> o el operador <code>+</code>. Pero no olvides que esos también son correctos:</p>
<pre class="python"><code>t.append(x)
t = t + [x]</code></pre>
<p>Y esos son incorrectos:</p>
<pre class="python"><code>t.append([x])          # ¡EQUIVOCADO!
t = t.append(x)        # ¡EQUIVOCADO!
t + [x]                # ¡EQUIVOCADO!
t = t + x              # ¡EQUIVOCADO!</code></pre>
<p>Prueba cada uno de esos ejemplos en modo interactivo para asegurarte que entiendes lo que hacen. Nota que solamente la última provoca un error en tiempo de ejecución (runtime error); los otros tres son válidos, pero hacen la función equivocada.</p></li>
<li><p>Hacer copias para evitar alias.</p>
<p> </p>
<p>Si quieres utilizar un método como <code>sort</code> que modifica el argumento, pero necesitas mantener la lista original también, puedes hacer una copia.</p>
<pre class="python"><code>orig = t[:]
t.sort()</code></pre>
<p>En este ejemplo podrías tambien usar la función interna <code>sorted</code>, la cual regresa una lista nueva y ordenada, y deja la original sin modificar. ¡Pero en ese caso deberías evitar usar <code>sorted</code> como un nombre de variable!</p></li>
<li><p>Listas, <code>split</code>, y archivos</p>
<p>Cuando leemos y analizamos archivos, hay muchas oportunidades de encontrar entradas que pueden hacer fallar a nuestro programa, así que es una buena idea revisar el patrón <em>guardián</em> cuando escribimos programas que leen a través de un archivo y buscan una “aguja en un pajar”.</p>
<p>Vamos a revisar nuestro programa que busca por el día de la semana en las líneas que contienen “from” en el archivo":</p>
<pre><code>From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008</code></pre>
<p>Puesto que estamos dividiendo esta línea en palabras, podríamos apañarnos con el uso de <code>startswith</code> y simplemente buscar la primer palabra de la línea para determinar si estamos interesados en esa línea o no. Podemos usar <code>continue</code> para saltarnos líneas que no tienen “From” como la primer palabra, tal como sigue:</p>
<pre class="python"><code>manejador = open(&#39;mbox-short.txt&#39;)
for linea in manejador:
    palabras = linea.split()
    if palabras[0] != &#39;From&#39; : continue
    print(palabras[2])</code></pre>
<p>Esto se ve mucho más simple y ni siquiera necesitamos hacer <code>rstrip</code> para remover el salto de línea al final del archivo. Pero, ¿es mejor?</p>
<pre><code>python search8.py
Sat
Traceback (most recent call last):
  File &quot;search8.py&quot;, line 5, in &lt;module&gt;
    if palabras[0] != &#39;From&#39; : continue
IndexError: list index out of range</code></pre>
<p>De alguna manera funciona y vemos el día de la primer línea (Sat), pero luego el programa falla con un error. ¿Qué fue lo que falló? ¿Qué datos estropearon e hicieron fallar a nuestro elegante, inteligente, y muy Pythónico programa?</p>
<p>Puedes mirar el código por un largo tiempo y tratar de resolverlo o preguntar a alguien más, pero el método más rápido e inteligente es agregar una sentencia <code>print</code>. El mejor lugar para agregar la sentencia “print” es justo antes de la línea donde el programa falló, e imprimir los datos que parece que causan la falla.</p>
<p>Ahora bien, este método podría generar muchas líneas de salida, pero al menos tendrás inmediatamente alguna pista de cuál es el problema. Así que agregamos un print a la variable <code>palabras</code> justo antes de la línea cinco. Incluso podemos agregar un prefijo “Depuración:” a la línea de modo que mantenemos nuestra salida regular separada de la salida de mensajes de depuración.</p>
<pre class="python"><code>for linea in manejador:
    palabras = line.split()
    print(&#39;Depuración:&#39;, palabras)
    if palabras[0] != &#39;From&#39; : continue
    print(palabras[2])</code></pre>
<p>Cuando ejecutamos el programa, se generan muchos mensajes de salida en la pantalla, pero al final, vemos nuestra salida de depuración y el mensaje de error, de modo que sabemos qué sucedió justo antes del error.</p>
<pre><code>Debug: [&#39;X-DSPAM-Confidence:&#39;, &#39;0.8475&#39;]
Debug: [&#39;X-DSPAM-Probability:&#39;, &#39;0.0000&#39;]
Debug: []
Traceback (most recent call last):
  File &quot;search9.py&quot;, line 6, in &lt;module&gt;
    if palabras[0] != &#39;From&#39; : continue
IndexError: list index out of range</code></pre>
<p>Cada línea de depuración imprime la lista de palabras que obtuvimos cuando la función <code>split</code> dividió la línea en palabras. Cuando el programa falla, la lista de palabras está vacía <code>[]</code>. Si abrimos el archivo en un editor de texto y miramos el archivo, en ese punto se ve lo siguiente:</p>
<pre><code>X-DSPAM-Result: Innocent
X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000

Details: http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772</code></pre>
<p>¡El error ocurre cuando nuestro programa encuentra una línea vacía! Por supuesto, hay “cero palabras” en una lista vacía. ¿Por qué no pensamos en eso cuando estábamos escribiendo el código? Cuando el código busca la primera palabra (<code>palabras[0]</code>) para revisar si coincide con “From”, obtenemos un error “index out of range” (índice fuera de rango).</p>
<p>Este es, por supuesto, el lugar perfecto para agregar algo de <em>código guardián</em> para evitar revisar la primer palabra si la primer palabra no existe. Hay muchas maneras de proteger este código; vamos a optar por revisar el número de palabras que tenemos antes de mirar a la primer palabra:</p>
<pre class="python"><code>manejador = open(&#39;mbox-short.txt&#39;)
contador = 0
for linea in manejador:
    palabras = linea.split()
    # print &#39;Depuración:&#39;, palabras
    if len(palabras) == 0 : continue
    if palabras[0] != &#39;From&#39; : continue
    print(palabras[2])</code></pre>
<p>Primero comentamos la sentencia de depuración en vez de removerla, en caso de que nuestra modificación falle y tengamos que depurar de nuevo. Luego, agregamos una sentencia guardián que revisa si tenemos cero palabras, y si así fuera, utilizamos <code>continue</code> para saltarnos a la siguiente línea en el archivo.</p>
<p>Podemos pensar en las dos sentencias <code>continue</code> para ayudarnos a redefinir el juego de líneas que son “interesantes” para nosotros y cuáles queremos procesar más. Una línea que no tenga palabras “no es interesante” para nosotros así que saltamos a la siguiente línea. Una línea que no tenga “From” como su primera palabra tampoco nos interesa así que la saltamos.</p>
<p>El programa modificado ejecuta exitosamente, así que quizás es correcto. Nuestra sentencia guardián se asegura de que <code>palabras[0]</code> nunca falle, pero quizá no sea suficiente. Cuando estamos programando, siempre debemos pensar, “¿qué podría salir mal?”</p></li>
</ol>
<p><strong>Ejercicio 2: Encontrar que línea del programa de arriba no está protegida (método guardián) propiamente. Trata de construir un archivo de texto que cause que el programa falle y después modifica el programa de modo que la línea es propiamente protegida y pruébalo para asegurarte que el programa es capaz de manejar tu nuevo archivo de texto.</strong></p>
<p><strong>Ejercicio 3: Reescribe el código guardián en el ejemplo de arriba sin las dos sentencias <code>if</code>. En vez de eso, utiliza una expresión lógica compuesta utilizando el operador lógico <code>or</code> con una sola sentencia <code>if</code>.</strong></p>
<h2 id="glosario">Glosario</h2>
<dl>
<dt>alias</dt>
<dd>Una circunstancia donde dos o más variables apuntan al mismo objeto. 
</dd>
<dt>delimitador</dt>
<dd>Un caracter o cadena utilizado para indicar dónde una cadena debe ser dividida. 
</dd>
<dt>elemento</dt>
<dd>Uno de los valores en una lista (u otra secuencia); también llamados ítems. 
</dd>
<dt>equivalente</dt>
<dd>Que tiene el mismo valor. 
</dd>
<dt>idéntico</dt>
<dd>Ser el mismo objeto (lo cual implica equivalencia). 
</dd>
<dt>índice</dt>
<dd>Un valor entero que indica un elemento en una lista.  
</dd>
<dt>lista</dt>
<dd>Una secuencia de valores. 
</dd>
<dt>lista anidada</dt>
<dd>Una lista que es uno de los elementos de otra lista. 
</dd>
<dt>objeto</dt>
<dd>Algo a lo que una variable puede referirse. Un objeto tiene un tipo y un valor. 
</dd>
<dt>recorrido de lista</dt>
<dd>Acceso secuencial a cada elemento de una lista. 
</dd>
<dt>referencia</dt>
<dd>La asociación entre una variable y su valor. 
</dd>
</dl>
<h2 id="ejercicios">Ejercicios</h2>
<p></p>
<p><strong>Ejercicio 4: Descargar una copia de un archivo</strong> <a href="http://www.py4e.com/code3/romeo.txt"><strong>www.py4e.com/code3/romeo.txt</strong></a><strong>. Escribir un programa para abrir el archivo <em>romeo.txt</em> y leerlo línea por línea. Para cada línea, dividir la línea en una lista de palabras utilizando la función <code>split</code>. Para cada palabra, revisar si la palabra ya se encuentra previamente en la lista. Si la palabra no está en la lista, agregarla a la lista. Cuando el programa termine, ordenar e imprimir las palabras resultantes en orden alfabético.</strong></p>
<pre><code>Ingresar nombre de archivo: romeo.txt
[&#39;Arise&#39;, &#39;But&#39;, &#39;It&#39;, &#39;Juliet&#39;, &#39;Who&#39;, &#39;already&#39;,
&#39;and&#39;, &#39;breaks&#39;, &#39;east&#39;, &#39;envious&#39;, &#39;fair&#39;, &#39;grief&#39;,
&#39;is&#39;, &#39;kill&#39;, &#39;light&#39;, &#39;moon&#39;, &#39;pale&#39;, &#39;sick&#39;, &#39;soft&#39;,
&#39;sun&#39;, &#39;the&#39;, &#39;through&#39;, &#39;what&#39;, &#39;window&#39;,
&#39;with&#39;, &#39;yonder&#39;]</code></pre>
<p><strong>Ejercicio 5: Escribir un programa para leer a través de datos de una bandeja de entrada de correo y cuando encuentres una línea que comience con “From”, dividir la línea en palabras utilizando la función <code>split</code>. Estamos interesados en quién envió el mensaje, lo cual es la segunda palabra en las líneas que comienzan con From.</strong></p>
<pre><code>From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008</code></pre>
<p><strong>Tendrás que analizar la línea From e imprimir la segunda palabra de cada línea From, después tendrás que contar el número de líneas From (no incluir From:) e imprimir el total al final. Este es un buen ejemplo de salida con algunas líneas de salida removidas:</strong></p>
<pre><code>python fromcuenta.py
Ingresa un nombre de archivo: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...líneas de salida removidas...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
Hay 27 lineas en el archivo con la palabra From al inicio</code></pre>
<p><strong>Ejercicio 6: Reescribe el programa que pide al usuario una lista de números e imprime el máximo y el mínimo de los números al final cuando el usuario ingresa “hecho”. Escribe el programa para almacenar los números que el usuario ingrese en una lista, y utiliza las funciones <code>max()</code> y <code>min()</code> para calcular el máximo y el mínimo después de que el bucle termine.</strong></p>
<pre><code>Ingresa un número: 6
Ingresa un número: 2
Ingresa un número: 9
Ingresa un número: 3
Ingresa un número: 5
Ingresa un número: hecho
Máximo: 9.0
Minimo: 2.0</code></pre>
</body>
</html>
