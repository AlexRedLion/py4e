
Listas
=====

\index{lista}
\index{type!lista}

Una lista es una secuencia
--------------------

Así como una cadena, una *lista* es una secuencia de valores. En una
cadena, los valores son caracteres; en una lista, pueden ser cualquier tipo. Los
valores en una lista son llamados *elementos* o a veces
*ítems*.

\index{elemento}
\index{secuencia}
\index{item}

Hay varias formas de crear una nueva lista; la más simple es encerrar
los elementos en corchetes ("[" y "]"):

~~~~ {.python}
[10, 20, 30, 40]
['rana crujiente', 'vejiga de carnero', 'vómito de alondra']
~~~~

El primer ejemplo es una lista de 4 enteros. La segunda es una lista de
tres cadenas. Los elementos de una lista no tienen que ser del mismo tipo.
La siguiente lista contiene una cadena, un flotante, un entero, y (¡mira!)
otra lista:

~~~~ {.python}
['spam', 2.0, 5, [10, 20]]
~~~~ 

Una lista dentro de otra lista está *anidada*.

\index{lista anidada}
\index{lista!anidada}

Una lista que no contiene elementos es llamada una lista vacía; puedes crear
una con corchetes vacíos, `[]`.

\index{lista vacía}
\index{lista!vacía}

Como puedes ver, puedes asignar los valores de una lista a variables:

~~~~ {.python .trinket}
>>> quesos = ['Cheddar', 'Edam', 'Gouda']
>>> numeros = [17, 123]
>>> vacia = []
>>> print(quesos, numeros, vacia)
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
~~~~

\index{asignación}

Las listas son mutables
-----------------

\index{lista!elemento}
\index{acceso}
\index{index}
\index{}
\index{operador corchete}
\index{operador!corchete}

La sintaxis para accesar elementos de una lista es la misma que para
accesar los caracteres de una cadena: el operador corchete. La
expresión dentro de los corchetes especifíca el índice. Recordemos que los
índices empiezan en 0:

~~~~ {.python}
>>> print(quesos[0])
Cheddar
~~~~

A diferencia de las cadenas, las listas son mutables porque pueden cambiar el orden de
los elementos en una lista o reasignar un elemento en una lista. Cuando el operador corchete
aparece en el lado izquierdo de una asignación, éste identifica el elemento de la
lista que será asignado.

\index{mutabilidad}

~~~~ {.python .trinket}
>>> numeros = [17, 123]
>>> numeros[1] = 5
>>> print(numeros)
[17, 5]
~~~~

El elemento en la posición uno de `numeros`, el cual solía ser 123, es
ahora 5.

\index{index!comenzando con cero}
\index{cero, indice comenzando con}

Puedes pensar en una lista como una relación entre índices y elementos.
Esta relación es llamada *mapeo*; cada índice "mapea
a" uno de los elementos.

\index{asignacion de elementos}
\index{asignacion de!elementos}

Los índices en una lista funcionan de la misma manera que los índices de una cadena:

-   Cualquier forma de entero puede ser utilizada como índice.

-   Si tratas de leer o escribir un elemento que no existe, obtendrás
    un `IndexError`.

\index{excepcion!IndexError}
\index{IndexError}

-   Si un índice tiene un valor negativo, éste cuenta hacia atrás desde el final
    de la lista.

\index{lista!indice}
\index{lista!membresia}
\index{membresia!lista}
\index{operador in}
\index{operador!in}

El operador `in` funciona también en listas.

~~~~ {.python .trinket}
>>> quesos = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in quesos
True
>>> 'Brie' in quesos
False
~~~~

Recorriendo una lista
-----------------

\index{lista!recorrido}
\index{recorrido!lista}
\index{bucle for}
\index{bucle!for}
\index{sentencia!for}

La forma más común de recorrer los elementos de una lista es con un
bucle `for`. La sintaxis es la misma que para las cadenas:

~~~~ {.python}
for queso in quesos:
    print(queso)
~~~~

Esto funciona bien si solamente necesitas leer los elementos de la lista. Pero
si quieres escribir o actualizar los elementos, necesitas los índices. Una
forma común de hacer eso es combinando las funciones `range` y
`len`:

\index{recorriendo!con indices}
\index{indices!recorriendo con}

~~~~ {.python}
for i in range(len(numeros)):
    numeros[i] = numeros[i] * 2
~~~~

Este bucle recorre la lista y actualiza cada elemento. `len`
regresa el número de elementos en una lista. `range` regresa una
lista de índices desde 0 hasta $n-1$, donde $n$ es la longitud de la lista.
Cada vez que pasa a través del recorrido, `i` obtiene el índice del siguiente
elemento. La sentencia de asignación dentro del bucle utiliza `i` para
leer el valor original del elemento y asignar un nuevo valor.

\index{item actualizacion}
\index{actualizacion!item}

Un bucle `for` a través de una lista vacía nunca ejecuta el código contenido en el cuerpo:

~~~~ {.python}
for x in vacia:
    print('Esto nunca sucede.')
~~~~

Aunque una lista puede contener otra lista, las listas anidadas siguen
contando como un solo elemento. El tamaño de esta lista es cuatro:

\index{lista anidada}
\index{lista!anidada}

~~~~ {.python}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
~~~~

Operaciones de listas
---------------

\index{lista!operaciones}

El operador `+` concatena listas:

\index{concatenacion!lista}
\index{lista!concatenacion}

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
~~~~

De igual forma, el operador `*` repite una lista un determinado número de veces:

\index{repeticion!lista}
\index{lista!repeticion}

~~~~ {.python .trinket}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
~~~~

En el primer ejemplo se repite cuatro veces. En el segundo ejemplo se repite la
lista tres veces.

Rebanado de listas
-----------

\index{rebanado operador}
\index{operador!rebanado}
\index{indice!rebanado}
\index{lista!rebanado}
\index{rebanado!lista}

El operador de rebanado también funciona en listas:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
~~~~

Si omites el primer índice, el rebanado comienza desde el inicio de la lista.
Si omites el segundo, el rebanado se va hasta el final. Así que si omites ambos,
el rebanado es una copia de la lista completa.

\index{lista!copia}
\index{rebanado!copia}
\index{copia!rebanado}

~~~~ {.python}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
~~~~

Como las listas son mutables, a veces es útil hacer una copia antes
de hacer operaciones que doblan, pegan, o cortan listas.

\index{mutabilidad}

Un operador de rebanado al lado izquierdo de una asignación puede actualizar
múltiples elementos:

\index{rebanado!actualizar}
\index{actualizar!rebanado}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
~~~~

Métodos de listas
------------

\index{lista!metodo}
\index{metodo, lista}

Python provee métodos que operan en listas. Por ejemplo,
`append` agrega un nuevo elemento al final de una lista:

\index{append metodo}
\index{metodo!append}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print(t)
['a', 'b', 'c', 'd']
~~~~

`extend` toma una lista como argumento y agrega todos
los elementos:

\index{extender metodo}
\index{metodo!extender}

~~~~ {.python .trinket}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print(t1)
['a', 'b', 'c', 'd', 'e']
~~~~

Este ejemplo deja `t2` sin modificar.

`sort` ordena los elementos de la lista de menor a mayor:

\index{ordenar metodo}
\index{metodo!ordenar}

~~~~ {.python .trinket}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print(t)
['a', 'b', 'c', 'd', 'e']
~~~~

La mayoría de métodos no regresan nada; modifican la lista y regresan
`None`. Si accidentalmentes escribes `t = t.sort()`,
vas a decepcionarte con el resultado.

\index{vacío metodo}
\index{metodo!vacío}
\index{None valor especial}
\index{especial valor!None}

Eliminando elementos
-----------------

\index{elemento eliminación}
\index{eliminación, elemento de lista}

Hay varias formas de eliminar elementos de una lista. Si sabes el índice
del elemento que quieres, puedes usar `pop`:

\index{pop método}
\index{método!pop}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print(t)
['a', 'c']
>>> print(x)
b
~~~~

`pop` modifica la lista y regresa el elemento que fue
removido. Si no provees un índice, la función elimina y retorna el último
elemento.

Si no necesitas el valor removido, puedes usar el
operador `del`:

\index{del operador}
\index{operador!del}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print(t)
['a', 'c']
~~~~

Si sabes qué elemento quieres remover (pero no sabes el índice), puedes
usar `remove`:

\index{remover método}
\index{método!remover}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print(t)
['a', 'c']
~~~~

El valor de retorno de `remove` es `None`.

\index{None valor especial}
\index{valor especial!None}

Para remover más de un elemento, puedes usar `del` con un
índice de rebanado:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print(t)
['a', 'f']
~~~~

Como siempre, el rebanado selecciona todos los elementos hasta, pero excluyendo,
el segundo índice.

Listas y funciones
-------------------

Hay un cierto número funciones internas que pueden ser utilizadas en las listas
que te permiten mirar rápidamente a través de una lista sin escribir tus propios bucles:

~~~~ {.python .trinket}
>>> nums = [3, 41, 12, 9, 74, 15]
>>> print(len(nums))
6
>>> print(max(nums))
74
>>> print(min(nums))
3
>>> print(sum(nums))
154
>>> print(sum(nums)/len(nums))
25
~~~~

La función `sum()` solamente funciona cuando los elementos de la lista
son números. Las otras funciones (`max()`, `len()`,
etc.) funcionan con listas de cadenas y otros tipos que pueden ser comparados entre sí.

Podríamos reescribir un programa anterior que calculaba el promedio de una lista de
números ingresados por el usuario utilizando una lista.

Primero, el programa para calcular un promedio sin una lista:

\VerbatimInput{../code3/avenum.py}

En este programa, tenemos las variables `count` y `total`
para almacenar la cantidad y el total actual de los números del usuario según
el usuario va ingresando los números repetidamente.

Podríamos simplemente recordar cada número como el número lo ingresó, y utilizar
funciones internas para calcular la suma y el total de números al final.

\VerbatimInput{../code3/avelist.py}

Creamos una lista vacía antes de que comience el bucle, y luego cada vez que
tengamos un número, lo agregamos a la lista. Al final del programa, simplemente
calculamos la suma de los números en la lista y la dividimos por el total de
números en la lista para obtener el promedio.

Listas y cadenas
-----------------

\index{lista}
\index{cadena}
\index{secuencia}

Una cadena es una secuencia de caracteres y una lista es una secuencia de valores,
pero una lista de caracteres no es lo mismo que una cadena. Para convertir una
cadena en una lista de caracteres, puedes usar `list`:

\index{lista!funcion}
\index{funcion!lista}

~~~~ {.python .trinket}
>>> s = 'spam'
>>> t = list(s)
>>> print(t)
['s', 'p', 'a', 'm']
~~~~

Debido a que `list` es el nombre de una función interna, debes
evitar usarla como un nombre de variable. Yo trato de evitar también
la letra "l" porque se parece mucho al número "1".
Así que por eso utilizo "t".

La función `list` divide una cadena en letras individuales.
Si quieres dividir una cadena en palabras, puedes utilizar el método
`split`:

\index{division metodo}
\index{metodo!division}

~~~~ {.python .trinket}
>>> s = 'suspirando por los fiordos'
>>> t = s.split()
>>> print(t)
['suspirando', 'por', 'los', 'fiordos']
>>> print(t[2])
the
~~~~

Una vez que hayas utilizado `split` para dividir una cadena en una lista de
palabras, puedes utilizar el operador índice (corchetes) para ver una palabra
en particular en la lista.

Puedes llamar `split` con un argumento opcional llamado
*delimitador* que especifica qué caracteres usar para delimitar las palabras.
El siguiente ejemplo utiliza un guión medio como delimitador:

\index{opcional argumento}
\index{argumento!opcional}
\index{delimitador}

~~~~ {.python .trinket}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> s.split(delimiter)
['spam', 'spam', 'spam']
~~~~

`join` es el inverso de `split`. Este toma una lista de cadenas
y concatena los elementos. `join` es un método de cadenas,
así que tienes que invocarlo en el delimitador y pasar la lista
como un parámetro:

\index{juntar metodo}
\index{metodo!juntar}
\index{concatenacion}

~~~~ {.python .trinket}
>>> t = ['suspirando', 'por', 'los', 'fiordos']
>>> delimiter = ' '
>>> delimiter.join(t)
'suspirando por los fiordos'
~~~~

En este caso el delimitador es un caracter de espacio, así que `join`
agrega un espacio entre las palabras. Para concatenar cadenas sin espacios,
puedes usar la cadena vacía, "", como delimitador.

\index{cadena vacia}
\index{vacia!cadena}

Analizando líneas
-------------

Normalmente cuando estamos leyendo un archivo queremos hacer algo con las líneas
que no sea solamente imprimir las líneas como son. Frecuentemente queremos encontrar las
"líneas interesantes" y después *analizar* la línea para encontrar
alguna "parte interesante" en la línea. ¿Qué tal si quisiéramos imprimir el día de la semana
de las líneas que comienzan con "From "?

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
~~~~

El método `split` es muy efectivo cuando nos encontramos este tipo de
problemas. Podemos escribir un pequeño programa que busca líneas donde
la línea comienza con "From ", `split` (dividir) esas líneas, y finalmente
imprimir la tercer palabra de la línea:

\VerbatimInput{../code3/search5.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

El programa produce lo siguiente:

    Sat
    Fri
    Fri
    Fri
    ...

Más tarde, aprenderemos técnicas muy sofisticadas para obtener las
líneas que queremos para trajar sobre ellas y cómo sacar el
fragmento exacto de información que estamos buscando.

Objetos y valores
------------------

\index{objeto}
\index{valor}

Si ejecutamos las siguientes sentencias de asignación:

~~~~ {.python}
a = 'banana'
b = 'banana'
~~~~

sabemos que ambos `a` y `b` se refieren a una cadena,
pero no sabemos si se refieren o apuntan a la *misma* cadena. Hay dos
estados posibles:

\index{alias}

![Variables y objetos](height=0.5in@../images/list1)

Por un lado, `a` y `b` se refieren a dos objetos
diferentes que tienen el mismo valor. Por otro lado, apuntan al mismo objeto.

\index{operador is}
\index{is!operador}

Para revisar si dos variables apuntan al mismo objeto, puedes utilizar el
operador `is`.

~~~~ {.python .trinket}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
~~~~

En este ejemplo, Python solamente creó un objeto de cadena, y ambos
`a` y `b` apuntan a él.

Pero cuando creas dos listas, obtienes dos objetos diferentes:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
~~~~

En este caso podríamos decir que las dos listas son
*equivalentes*, porque tienen los mismos elementos, pero
no *idénticas*, porque no son el mismo objeto. Si
dos objetos son idénticos, son también equivalentes, pero si son
equivalentes, no son necesariamente idénticos.

\index{equivalencia}
\index{identidad}

Hasta ahora, hemos estado usando "objeto" y "valor" de forma intercambiable, pero
es más preciso decir que un objeto tiene un valor. Si ejecutas
`a = [1,2,3]`, `a` se refiere a una lista de objetos cuyo
valor es una secuencia particular de elementos. Si otra lista tiene los mismos
elementos, diríamos que tiene el mismo valor.

\index{objeto}
\index{valor}

Alias
--------

\index{alias}
\index{alias!referencia}

Si `a` se refiere a un objecto y tu asignas`b = a`,
entonces ambas variables se refieren al mismo objeto:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
~~~~

La asociación de una variable a un objeto es llamada una *referencia*.
En este ejemplo, hay dos referencias al
mismo objeto.

\index{referencia}

Un objeto con más de una referencia tiene más de un nombre, así que decimos
que el objeto es un *alias*.

\index{mutabilidad}

Si el alias del objeto es mutable, los cambios hechos a un alias afectan al
otro:

~~~~ {.python}
>>> b[0] = 17
>>> print(a)
[17, 2, 3]
~~~~

Aunque este comportamiento puede ser útil, es propenso a errores. En general, es
más seguro evitar usar alias cuando estás trabajando con objetos mutables.

\index{inmutabilidad}

Para objetos inmutables como cadenas, los alias no son un problema
realmente. En este ejemplo:

~~~~ {.python}
a = 'banana'
b = 'banana'
~~~~

casi nunca hay diferencia si `a` y
`b` apuntan a la misma cadena o no.

Listas como argumentos
--------------

\index{listas!como argumento}
\index{argumento}
\index{lista!argumento}
\index{referencia}
\index{parametro}

Cuando pasas una lista a una función, la función obtiene un apuntador a
la lista. Si la función modifica un parámetro de la lista, el código que ha llamado la función
también verá el cambio. Por ejemplo, `remover_primero` elimina el primer elemento de
una lista:

~~~~ {.python}
def remover_primero(t):
    del t[0]
~~~~

Aquí está el ejemplo de cómo se usa:

~~~~ {.python .trinket}
>>> letras = ['a', 'b', 'c']
>>> remover_primero(letras)
>>> print(letras)
['b', 'c']
~~~~

El parámetro `t` y la variable `letras` son
alias para el mismo objeto.

Es importante distinguir entre operaciones que modifican listas y
operaciones que crean nuevas listas. Por ejemplo, el método `append`
modifica una lista, pero el operador `+` crea una nueva
lista:

\index{agregar metodo}
\index{metodo!agregar}
\index{lista!concatenacion}
\index{concatenacion!lista}

~~~~ {.python .trinket}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print(t1)
[1, 2, 3]
>>> print(t2)
None

>>> t3 = t1 + [3]
>>> print(t3)
[1, 2, 3]
>>> t2 is t3
False
~~~~

Esta diferencia es importante cuando escribes funciones que no están destinadas
a modificar listas. Por ejemplo, esta función *no* elimina el primer elemento
de una lista:

~~~~ {.python}
def mal_eliminar_primero(t):
    t = t[1:]              # ¡EQUIVOCADO!
~~~~

El operador de rebanado crea una nueva lista y el asignamiento hace que
`t` apunte a la lista, pero nada de esto tiene efecto en la lista
que fue pasada como argumento.

\index{operador rebanado}
\index{rebanado!operador}

Una alternativa es escribir una función que cree y regrese una nueva
lista. Por ejemplo, `cola` regresa todo excepto el primer elemento de
una lista:

~~~~ {.python}
def cola(t):
    return t[1:]
~~~~

Esta función deja la lista original sin modificar. Aquí está como es que
se usa:

~~~~ {.python .trinket}
>>> letras = ['a', 'b', 'c']
>>> resto = cola(letras)
>>> print(resto)
['b', 'c']
~~~~

**Ejercicio 1: Write a function called `chop` that takes a list and modifies
it, removing the first and last elements, and returns `None`. Then write a function called `middle` that takes a list and returns a new list that contains all but the first and last elements.**

Debugging
---------

\index{debugging}

Careless use of lists (and other mutable objects) can lead to long hours
of debugging. Here are some common pitfalls and ways to avoid them:

1.  Don't forget that most list methods modify the argument and return
    `None`. This is the opposite of the string methods, which
    return a new string and leave the original alone.

    If you are used to writing string code like this:

    ~~~~ {.python}
    word = word.strip()
    ~~~~

    It is tempting to write list code like this:

    ~~~~ {.python}
    t = t.sort()           # WRONG!
    ~~~~

    \index{sort method}
    \index{method!sort}

    Because `sort` returns `None`, the next
    operation you perform with `t` is likely to fail.

    Before using list methods and operators, you should read the
    documentation carefully and then test them in interactive mode. The
    methods and operators that lists share with other sequences (like
    strings) are documented at:

    [docs.python.org/library/stdtypes.html#common-sequence-operations](https://docs.python.org/library/stdtypes.html#common-sequence-operations)

    The methods and operators that only apply to mutable sequences are
    documented at:

    [docs.python.org/library/stdtypes.html#mutable-sequence-types](https://docs.python.org/library/stdtypes.html#mutable-sequence-types)

2.  Pick an idiom and stick with it.

    \index{idiom}

    Part of the problem with lists is that there are too many ways to do
    things. For example, to remove an element from a list, you can use
    `pop`, `remove`, `del`, or even a
    slice assignment.

    To add an element, you can use the `append` method or the
    `+` operator. But don't forget that these are right:

    ~~~~ {.python}
    t.append(x)
    t = t + [x]
    ~~~~

    And these are wrong:

    ~~~~ {.python}
    t.append([x])          # WRONG!
    t = t.append(x)        # WRONG!
    t + [x]                # WRONG!
    t = t + x              # WRONG!
    ~~~~

    Try out each of these examples in interactive mode to make sure you
    understand what they do. Notice that only the last one causes a
    runtime error; the other three are legal, but they do the wrong
    thing.

3.  Make copies to avoid aliasing.

    \index{aliasing!copying to avoid}
    \index{copy!to avoid aliasing}

    If you want to use a method like `sort` that modifies the
    argument, but you need to keep the original list as well, you can
    make a copy.

    ~~~~ {.python}
    orig = t[:]
    t.sort()
    ~~~~

    In this example you could also use the built-in function
    `sorted`, which returns a new, sorted list and leaves the
    original alone. But in that case you should avoid using
    `sorted` as a variable name!

4.  Lists, `split`, and files

    When we read and parse files, there are many opportunities to
    encounter input that can crash our program so it is a good idea to
    revisit the *guardian* pattern when it comes writing
    programs that read through a file and look for a "needle in the
    haystack".

    Let's revisit our program that is looking for the day of the week on
    the from lines of our file:

    ~~~~
    From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
    ~~~~

    Since we are breaking this line into words, we could dispense with
    the use of `startswith` and simply look at the first word
    of the line to determine if we are interested in the line at all. We
    can use `continue` to skip lines that don't have "From"
    as the first word as follows:

    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    for line in fhand:
        words = line.split()
        if words[0] != 'From' : continue
        print(words[2])
    ~~~~

    This looks much simpler and we don't even need to do the
    `rstrip` to remove the newline at the end of the file.
    But is it better?

    ~~~~
    python search8.py
    Sat
    Traceback (most recent call last):
      File "search8.py", line 5, in <module>
        if words[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~

    It kind of works and we see the day from the first line (Sat), but
    then the program fails with a traceback error. What went wrong? What
    messed-up data caused our elegant, clever, and very Pythonic program
    to fail?

    You could stare at it for a long time and puzzle through it or ask
    someone for help, but the quicker and smarter approach is to add a
    `print` statement. The best place to add the print
    statement is right before the line where the program failed and
    print out the data that seems to be causing the failure.

    Now this approach may generate a lot of lines of output, but at
    least you will immediately have some clue as to the problem at hand.
    So we add a print of the variable `words` right before
    line five. We even add a prefix "Debug:" to the line so we can keep
    our regular output separate from our debug output.

    ~~~~ {.python}
    for line in fhand:
        words = line.split()
        print('Debug:', words)
        if words[0] != 'From' : continue
        print(words[2])
    ~~~~

    When we run the program, a lot of output scrolls off the screen but
    at the end, we see our debug output and the traceback so we know
    what happened just before the traceback.

    ~~~~
    Debug: ['X-DSPAM-Confidence:', '0.8475']
    Debug: ['X-DSPAM-Probability:', '0.0000']
    Debug: []
    Traceback (most recent call last):
      File "search9.py", line 6, in <module>
        if words[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~

    Each debug line is printing the list of words which we get when we
    `split` the line into words. When the program fails, the
    list of words is empty `[]`. If we open the file in a text editor
    and look at the file, at that point it looks as follows:

    ~~~~
    X-DSPAM-Result: Innocent
    X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
    X-DSPAM-Confidence: 0.8475
    X-DSPAM-Probability: 0.0000

    Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
    ~~~~

    The error occurs when our program encounters a blank line! Of course
    there are "zero words" on a blank line. Why didn't we think of that
    when we were writing the code? When the code looks for the first
    word (`word[0]`) to check to see if it matches "From", we get an
    "index out of range" error.

    This of course is the perfect place to add some
    *guardian* code to avoid checking the first word if
    the first word is not there. There are many ways to protect this
    code; we will choose to check the number of words we have before we
    look at the first word:

    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    count = 0
    for line in fhand:
        words = line.split()
        # print 'Debug:', words
        if len(words) == 0 : continue
        if words[0] != 'From' : continue
        print(words[2])
    ~~~~ 

    First we commented out the debug print statement instead of removing
    it, in case our modification fails and we need to debug again. Then
    we added a guardian statement that checks to see if we have zero
    words, and if so, we use `continue` to skip to the next
    line in the file.

    We can think of the two `continue` statements as helping
    us refine the set of lines which are "interesting" to us and which
    we want to process some more. A line which has no words is
    "uninteresting" to us so we skip to the next line. A line which does
    not have "From" as its first word is uninteresting to us so we skip
    it.

    The program as modified runs successfully, so perhaps it is correct.
    Our guardian statement does make sure that the `words[0]`
    will never fail, but perhaps it is not enough. When we are
    programming, we must always be thinking, "What might go wrong?"

**Exercise 2: Figure out which line of the above program is still not
properly guarded. See if you can construct a text file which causes
the program to fail and then modify the program so that the line is
properly guarded and test it to make sure it handles your new text
file.**

**Exercise 3: Rewrite the guardian code in the above example without
two `if` statements. Instead, use a compound logical
expression using the `or` logical operator with a single
`if` statement.**

Glossary
--------

aliasing
:   A circumstance where two or more variables refer to the same object.
\index{aliasing}

delimiter
:   A character or string used to indicate where a string should be
    split.
\index{delimiter}

element
:   One of the values in a list (or other sequence); also called items.
\index{element}

equivalent
:   Having the same value.
\index{equivalent}

index
:   An integer value that indicates an element in a list.
\index{index}
\index{}

identical
:   Being the same object (which implies equivalence).
\index{identical}

list
:   A sequence of values.
\index{list}

list traversal
:   The sequential accessing of each element in a list.
\index{list!traversal}

nested list
:   A list that is an element of another list.
\index{nested list}

object
:   Something a variable can refer to. An object has a type and a value.
\index{object}

reference
:   The association between a variable and its value.
\index{reference}

Exercises
---------

\index{Romeo and Juliet}

**Exercise 4: Download a copy of the file**
[**www.py4e.com/code3/romeo.txt**](http://www.py4e.com/code3/romeo.txt)**.
Write a program to open the file *romeo.txt* and read it line
by line. For each line, split the line into a list of words using the
`split` function. For each word, check to see if the word is already in a list. If the word is not in the list, add it to the list.
When the program completes, sort and print the resulting words in
alphabetical order.**

~~~~
Enter file: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already',
'and', 'breaks', 'east', 'envious', 'fair', 'grief',
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft',
'sun', 'the', 'through', 'what', 'window',
'with', 'yonder']
~~~~

**Exercise 5: Write a program to read through the mail box data and when
you find line that starts with "From", you will split the line into
words using the `split` function. We are interested in who
sent the message, which is the second word on the From line.**

~~~~
From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008
~~~~

**You will parse the From line and print out the second word for each From
line, then you will also count the number of From (not From:) lines and
print out a count at the end. This is a good sample output with a few lines removed:**

~~~~
python fromcount.py
Enter a file name: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...some output removed...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
There were 27 lines in the file with From as the first word
~~~~

**Exercise 6: Rewrite the program that prompts the user for a list of
numbers and prints out the maximum and minimum of the numbers at the end
when the user enters "done". Write the program to store the numbers the
user enters in a list and use the `max()` and
`min()` functions to compute the maximum and minimum numbers
after the loop completes.**

~~~~
Enter a number: 6
Enter a number: 2
Enter a number: 9
Enter a number: 3
Enter a number: 5
Enter a number: done
Maximum: 9.0
Minimum: 2.0
~~~~
