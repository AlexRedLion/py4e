Bases de datos y SQL
====================

¿Qué es una base de datos?
--------------------------

\index{base de datos}

Una *base de datos* es un archivo que está organizado para almacenar datos.
La mayoría de las bases de datos están organizadas como diccionarios, en el
sentido de que realizan asociaciones entre claves y valores. La diferencia más
importante es que la base de datos se encuentra en el disco (u otro almacenamiento
permanente), de modo que su contenido se conserva después de que el programa
finaliza. Gracias a que la base de datos se guarda en almacenamiento permanente,
puede almacenar muchos más datos que un diccionario, que está limitado al tamaño
de memoria que tenga la computadora.

\index{índices!base de datos}

Como un diccionario, el software de una base de datos está diseñado para conseguir
que la inserción y acceso a los datos sean muy rápidos, incluso para grandes
cantidades de datos. Este software mantiene su rendimiento mediante la construcción
de índices, como datos añadidos a la base de datos que permiten al equipo saltar
rápidamente hasta una entrada concreta.

Existen muchos sistemas de bases de datos diferentes, que se utilizan para una
amplia variedad de propósitos. Algunos de ellos son: Oracle, MySQL, Microsoft SQL
Server, PostgreSQL, y SQLite. En este libro nos enfocaremos en SQLite, ya que se
trata de una base de datos muy común y ya viene integrada dentro de Python. SQLite
está diseñada para ser *incrustada* dentro de otras aplicaciones, de modo que
proporcione soporte para bases de datos dentro de la aplicación. Por ejemplo, el
navegador Firefox es uno de los que utilizan la base de datos SQLite internamente,
al igual que muchos otros productos.

<http://sqlite.org/>

SQLite es muy adecuado para ciertos problemas de manipulación de datos que nos
encontramos en informática, como en la aplicación de rastreo de Twitter que
hemos descrito en el capítulo anterior.

Conceptos sobre bases de datos
------------------------------

Cuando se ve por primera vez una base de datos, se parece a una hoja de cálculo con
múltiples hojas. Las estructuras de datos primarias en una base de datos son:
*tablas*, *files*, and
*columnas*.

![Bases de datos relacionales](height=2.0in@../images/relational)

En las descripciones técnicas de las bases de datos relacionales, los conceptos
de tabla, fila y columna reciben los nombres más formales de
*relación*, *tupla*, y
*atributo*, respectivamente. Nosotros utilizaremos los términos menos formales
en este capítulo.


Navegador de bases de datos para SQLite
---------------------------------------

A pesar de que en este capítulo nos enfocaremos en utilizar Python para trabajar
con datos en archivos de bases de datos SQLite, muchas operaciones pueden ser hechas
de forma más eficaz usando un programa de software llamado *Database Browser for SQLite*,
que se puede descargar gratis desde:

<http://sqlitebrowser.org/>

Utilizando el navegador se pueden crear tablas, insertar datos, editar datos,
o ejecutar consultas SQL sencillas sobre la base de datos.

En cierto modo, el navegador de base de datos es parecido a un editor de texto
que trabaja con archivos de texto. Cuando quieres realizar uno o dos cambios en un
archivo de texto, lo más sencillo es abrirlo en un editor de texto y realizar los
cambios que quieres. Cuando debes realizar muchas modificaciones en el archivo, a
menudo habrá que escribir un programa en Python sencillo. El mismo enfoque se puede aplicar
al trabajo con bases de datos. Se realizarán las operaciones más sencillas en el gestor
de bases de datos, y para otras más complejas será más conveniente usar Python.

Creación de una tabla en una base de datos
------------------------------------------

Las bases de datos necesitan una estructura más definida que las listas o diccionarios
de Python^[SQLite en realidad permite cierta flexibilidad respecto al tipo de dato
que se almacena en cada columna, pero en este capítulo nosotros vamos a mantener los tipos
de datos estrictos, para que los conceptos que aprendamos puedan ser igualmente aplicados
a otras bases de datos como MySQL.].

Cuando creamos una *tabla*, debemos indicar de antemano a la base de datos los
nombres de cada una de las *columnas* de esa tabla y el tipo de dato que se va a
almacenar en cada una de ellas. Cuando el software de la base de datos conoce el tipo
de dato de cada columna, puede elegir el modo más eficiente de almacenar y buscar
en ellas, basándose en el tipo de dato que contendrán.

Puedes revisar los distintos tipos de datos soportados por SQLite en la
siguiente dirección:

<http://www.sqlite.org/datatypes.html>

El tener que definir de antemano una estructura para los datos puede parecer incómodo al
principio, pero la recompensa consiste en obtener un acceso rápido a los datos, incluso
cuando la base de datos contiene una gran cantidad de ellos.

El código para crear un archivo de base de datos y una tabla llamada `Canciones`
con dos columnas en la base de datos es el siguiente:

\index{módulo sqlite3}
\index{sqlite3!módulo}

\VerbatimInput{../code3/db1.py}

\index{función connect}
\index{connect!función}
\index{función cursor}
\index{cursor!función}

La operación `connect` realiza una conexión con la base de datos almacenada en el
archivo `musica.sqlite` en el directorio actual. Si el archivo no existe, se creará
uno nuevo. La razón de que se le llame una "conexión" es que a veces la base de datos
se almacena en un "servidor de bases de datos", distinto del servidor en el cual está
funcionando nuestra aplicación. En nuestros ejemplos, dado que son sencillos, la
base de datos será simplemente un archivo local en el mismo directorio en el que
está funcionando el código de Python.

Un *cursor* es como un manejador de archivos, y se puede usar para realizar operaciones
en los datos almacenados en la base de datos. La llamada a `cursor()` es muy similar
conceptualmente a la llamada `open()` cuando se está tratando con archivos
de texto.

![Un cursor de bases de datos](height=2.0in@../images/cursor)

Una vez que tenemos el cursor, podemos comenzar a ejecutar comandos sobre el contenido
de la base de datos, usando el método `execute()`.

Los comandos de las bases de datos se expresan en un lenguaje especial que ha sido
estandarizado entre varios proveedores de bases de datos diferentes para permitirnos
aprender un único lenguaje para todas ellas. Este lenguaje recibe el nombre de
*Lenguaje de Consultas Estructurado* (Structured Query Language), o *SQL*.

<https://es.wikipedia.org/wiki/SQL>

En nuestro ejemplo, estamos ejecutando dos comandos SQL sobre la base de datos.
Por convención, mostraremos las palabras claves de SQL en mayúscula y las partes
de los comandos que añadamos nosotros (como los nombres de las tablas y las columnas)
irán en minúsculas.

El primer comando SQL elimina la tabla `Canciones` si ya existe. Este planteamiento
se utiliza simplemente para permitirnos ejecutar el mismo programa para crear la tabla
`Canciones` una y otra vez sin provocar un error. Observa que el comando `DROP TABLE`
elimina la tabla y todo su contenido de la base de datos (es decir, aquí no existe la opción
"deshacer").

~~~~ {.python}
cur.execute('DROP TABLE IF EXISTS Canciones ')
~~~~

El segundo comando crea una tabla llamada `Canciones` con una columna de texto
llamada `titulo` y una columna de enteros llamada `reproducciones`.

~~~~ {.python}
cur.execute('CREATE TABLE Canciones (titulo TEXT, reproducciones INTEGER)')
~~~~

Ahora que ya hemos creado la tabla llamada `Canciones`, podemos guardar algunos
datos en ella usando la operación de SQL `INSERT`. Empezaremos realizando otra
vez una conexión con la base de datos y obteniendo el 
`cursor`. Luego podemos ejecutar comandos SQL usando ese
cursor.

El comando `INSERT` de SQL indica qué tabla se está utilizando y luego define una fila nueva,
enumerando los campos que se desean incluir `(titulo, reproducciones)` seguidos por los valores
(`VALUES`) que queremos colocar en esa fila. Nosotros vamos a especificar los valores como
signos de interrogación `(?, ?)` para indicarle que los valores reales serán pasados como
una tupla `( 'My Way', 15 ) ` en el segundo parámetro de la llamada a `execute()`.

\VerbatimInput{../code3/db2.py}

Primero insertamos (`INSERT`) dos filas en la tabla y usamos `commit()`
para forzar a que los datos sean escritos en el archivo de la base de
datos.

![Columnas en una tabla](height=1.5in@../images/tracks)

Después usamos el comando `SELECT` para recuperar las filas que acabamos de insertar
en la tabla. En el comando `SELECT`, indicamos qué columnas nos gustaría obtener
`(titulo, reproducciones)`, y también desde qué tabla queremos recuperar los
datos. Después de ejecutar la sentencia `SELECT`, el cursor se convierte en algo
con lo que podemos iterar mediante una sentencia `for`. Por eficiencia, el cursor no lee
todos los datos de la base de datos cuando se ejecuta la sentencia
`SELECT`. En lugar de ello, los datos van siendo leídos a medida que se van
pidiendo las filas desde el bucle creado con la sentencia `for`.

La salida del programa es la siguiente:

~~~~
Canciones:
('Thunderstruck', 20)
('My Way', 15)
~~~~

\index{Unicode}

Nuestro bucle `for` encuentra dos filas, y cada fila es una tupla de Python cuyo
primer valor es el `titulo` y el segundo es el número de `reproducciones`. 

*Nota: Puede que veas cadenas comenzando con `u'` en otros libros o en Internet.
Esto es una indicación en Python 2 que dice que las cadenas son cadenas *Unicode*
que son capaces de almacenar caracteres no-latinos. En Python 3, todas las cadenas
son del tipo `Unicode` por defecto.*

Al final del programa, ejecutamos un comando SQL para borrar (`DELETE`) las files
que acabamos de crear, de modo que podamos ejecutar el programa una y otra vez. El
comando `DELETE` nos muestra el uso de la cláusula `WHERE`, la cual nos permite
expresar un criterio de selección, de modo que podemos pedir a la base de datos
que aplique el comando solamente a las filas que cumplan ese criterio. En este
ejemplo, el criterio es cumplido por todas las filas, así que vaciamos la tabla
para que podamos ejecutar el programa de nuevo repetidamente. Después de que se ha
realizado el `DELETE`, llamamos de nuevo a `commit()` para forzar a los datos a ser
eliminados de la base de datos.

Resumen de Lenguaje de Consultas Estructurado
---------------------------------------------

Hasta ahora, hemos estado usando el Lenguaje de Consultas Estructurado (SQL)
en nuestros ejemplos de Python y hemos utilizado muchos de los comandos básicos
de SQL. En esta sección, nos centraremos en el lenguaje SQL en particular y
echaremos un vistazo a su sintaxis.

Debido a que hay muchos proveedores de bases de datos, el Lenguaje de Consultas
Estructurado (SQL) está estandarizado, para que podamos comunicarnos de una
forma similar con sistemas de bases de datos de múltiples vendedores.

Una base de datos relacional está compuesta por tablas, filas, y columnas. Las
columnas tienen generalmente un tipo de datos que puede ser texto, números, o
datos de fechas. Cuando se crea una tabla, se indican los nombres y tipos de cada
columna:

~~~~ {.sql}
CREATE TABLE Canciones (titulo TEXT, reproducciones INTEGER)
~~~~

Para insertar una fila en una tabla, usamos el comando de SQL `INSERT`:

~~~~ {.sql}
INSERT INTO Canciones (titulo, reproducciones) VALUES ('My Way', 15)
~~~~

La sentencia `INSERT` especifíca el nombre de la tabla, seguido por una lista de
los campos/columnas que se quieren establecer en la fila nueva, a continuación la
palabra clave `VALUES`, y una lista de los valores correspondientes para cada uno de
los campos.

El comando de SQL `SELECT`se utiliza para recuperar filas y columnas desde una base de
datos. La sentencia `SELECT` permite especificar qué columnas se quieren recibir, junto
con una clausula `WHERE` para indicar qué filas se desean obtener. También permite
una clausula opcional, `ORDER BY` para controlar el orden de las files devueltas.

~~~~ {.sql}
SELECT * FROM Canciones WHERE titulo = 'My Way'
~~~~

El uso de `*` indica que se desea que la base de datos devuelva todas las columnas para
cada línea que cumpla la condición de la clausula `WHERE`.

Hay que notar que, a diferencia de lo que ocurre en Python, en SQL la clausula
`WHERE` utiliza un único signo igual para indicar una comprobación de igualdad,
en lugar de utilizar un signo doble igual. Otras operaciones lógicas que se
permiten en una clausula `WHERE` son `<`, `>`, `<=`, `>=`, `!=`, así como también `AND`
y `OR`, y paréntesis para construir expresiones lógicas.

Se puede solicitar que las columnas devueltas vengan ordenadas por uno de los
campos, de este modo:

~~~~ {.sql}
SELECT titulo,reproducciones FROM Canciones ORDER BY titulo
~~~~

Para eliminar una fila, es necesario usar una clausula `WHERE` en una sentencia
`DELETE` de SQL. La clausula `WHERE` determina qué filas serán eliminadas:

~~~~ {.sql}
DELETE FROM Canciones WHERE titulo = 'My Way'
~~~~

Es posible actualizar (`UPDATE`) una columna o varias de una o más filas en una
tabla usando la secuencia de SQL `UPDATE`, como se muestra a continuación:

~~~~ {.sql}
UPDATE Canciones SET reproducciones = 16 WHERE titulo = 'My Way'
~~~~

La sentencia `UPDATE` especifíca una tabla, a continuación una lista de campos
y valores a cambiar detrás de la palabra clave `SET`, y finalmente una
clausula opcional `WHERE` para elegir las filas que van a ser actualizadas.
Una única sentencia `UPDATE` cambiará todas las filas que coincidan con la clausula
`WHERE`. Si no se ha especificado ninguna clausula `WHERE`, se realizará la
actualización (`UPDATE`) de todas las filas de la tabla.

Existen cuatro comandos básicos de SQL (INSERT, SELECT, UPDATE, y DELETE), que nos
permiten realizar las cuatro operaciones básicas necesarias para crear y mantener
datos.

Rastreo en Twitter usando una base de datos
-------------------------------------------

En esta sección, crearemos un programa araña sencillo que se moverá a través de
cuentas de Twitter y construirá una base de datos de ellas. *Nota: Ten mucho
cuidado cuando al ejecutar este programa. Si extraes demasiados datos o ejecutas
el programa durante demasiado tiempo pueden terminar cortándote el acceso a
Twitter.*

Uno de los problemas de cualquier tipo de programa araña es que se necesita
poderlo deener y volver a poner en marcha muchas veces, y no se quieren perder los
datos que se hayan recuperado hasta ese momento. No querrás tener que empezar siempre
la recuperación de datos desde el principio, de modo que necesitaremos almacenar
los datos según los vamos recuperando para que nuestro programa pueda usar esa
copia de seguridad y reanudar la recolección de datos desde donde lo dejó la
última vez.

Vamos a comenzar por recuperar los amigos de Twitter de una persona y sus estados,
moviéndonos a través de la lista de amigos y añadiendo cada uno de ellos a la base
de datos para poder recuperarlos en el futuro. Después de haber procesado todos los
amigos de esa persona, consultaremos la base de datos y recuperaremos los amigos de
uno de esos amigos. Continuaremos haciendo esto una y otra vez, recogiendo cualquier
persona "no visitada", recuperando su lista de amigos y añadiendo aquellos que no
tengamos ya en nuestra lista para una próxima visita.

También vamos a contar cuántas veces hemos visto un amigo concreto en la base
de datos, para tener una idea de su "popularidad".

Estamos almacenando nuestra lista de cuentas de conocidos, si hemos recuperado
la cuenta o no, y la popularidad de cada cuenta. Al tener todo ello guardado en
una base de datos en nuestro PC, podremos detener y reanudar el programa tantas
veces como queramos.

Este programa es un poco complejo. Está basado en el código de un ejercicio
anterior del libro que usa la API de Twitter.

Aquí está el código fuente para nuestra aplicación araña de Twitter:

\VerbatimInput{../code3/twspider.py}

Nuestra base de datos está almacenada en el archivo `arana.sqlite` y tiene
una tabla llamada `Twitter`. Cada fila en la tabla `Twitter` contiene una columna
para el nombre de la cuenta, otra para indicar si hemos recuperado los amigos
de esa cuenta, y otra para guardar cuántas veces se ha visto esa cuenta añadida
en la lista de amigos de las demás.

En el bucle principal del programa, pedimos al usuario el nombre de una cuenta
de Twitter o "salir" para finalizar el programa. Si el usuario introduce una cuenta
de Twitter, recuperamos la lista de amigos de ese usuario y sus estados, y
añadimos cada amigo a la base de datos, si no estaba ya en ella. Si el amigo ya
estaba en la lista, aumentamos en 1 el campo `amigos` en la fila correspondiente
de la base de datos.

Si el usuario presiona intro, buscamos en la base de datos la siguiente cuenta de
Twitter que no haya sido aún recuperada, recuperamos los amigos de esa cuenta y
sus estados, y luego los añadimos a la base de datos o los actualizamos, e
incrementamos su contador de `amigos`.

Una vez hemos recuperado la lista de amigos y sus estados, nos movemos a través
de los elementos `user` del JSON devuelto y recuperamos el `screen_name` (nombre
a mostrar) de cada usuario. Luego usamos la sentencia `SELECT` para comprobar
si ya tenemos almacenado ese nombre concreto en la base de datos y si es así
recuperamos su contador de amigos (`amigos`).

~~~~ {.python}
contnuevas = 0
contantiguas = 0
for u in js['users']:
    amigo = u['screen_name']
    print(amigo)
    cur.execute('SELECT amigos FROM Twitter WHERE nombre = ? LIMIT 1',
                (amigo, ))
    try:
        contador = cur.fetchone()[0]
        cur.execute('UPDATE Twitter SET amigos = ? WHERE nombre = ?',
                    (contador+1, amigo))
        contantiguas = contantiguas + 1
    except:
        cur.execute('''INSERT INTO Twitter (nombre, recuperado, amigos)
                    VALUES (?, 0, 1)''', (amigo, ))
        contnuevas = contnuevas + 1
print('Cuentas nuevas=', contnuevas, ' ya visitadas=', contantiguas)
conn.commit()
~~~~

Una vez que el cursor ejecuta la sentencia `SELECT`, tenemos que
recuperar las filas. Podríamos hacerlo con una sentencia `for`, pero dado
que sólo estamos recuperando una única fila (`LIMIT 1`), podemos también
usar el método `fetchone()` para extraer la primera (y única) fila que da
como resultado la operación `SELECT`. Dado que `fetchone()` devuelve la
fila como una *tupla* (incluso si sólo contiene un campo), tomamos el
primer valor de la tupla mediante [0], para almacenar así dentro de la
variable `contador` el valor del contador de amigos actual.

Si esta operación tiene éxito, usamos la sentencia `UPDATE` de SQL con
una clausula `WHERE` para añadir 1 a la columa `amigos` de aquella fila que
coincida con la cuenta del amigo. Fíjate que hay dos marcadores de posición (es
decir, signos de interrogación) en el SQL, y que el segundo parámetro de
`execute()` es una tupla de dos elementos que contiene los valores que
serán sustituidos por esas interrogaciones dentro de la sentencia SQL.

Si el código en el bloque `try` falla, se deberá probablemente a que ningún
registro coincide con lo especificado en la clausula `WHERE nombre = ?`
de la setencia SELECT. Así que en el bloque `except`, usamos la sentencia
de SQL `INSERT` para añadir el nombre a mostrar (`screen_name`) del amigo a la
tabla, junto con una indicación de que no lo hemos recuperado aún, y fijamos
su contador de amigos a cero.

La primera vez que el programa funciona e introducimos una cuenta de Twitter,
mostrará algo similar a esto:

~~~~
Ingresa una cuenta de Twitter, o salir: drchuck
Recuperando http://api.twitter.com/1.1/friends ...
Cuentas nuevas= 20  ya visitadas= 0
Ingresa una cuenta de Twitter, o salir: salir
~~~~

Dado que es la primera vez que ejecutamos el programa, la base de datos
está vacía, así que creamos el archivo `arana.sqlite` y añadimos una
tabla llamada `Twitter` a la base de datos. A continuación recuperamos
algunos amigos y los añadimos a la base de datos, ya que ésta está vacía.

En este punto, tal vez sea conveniente escribir un programa de volcado
de datos sencillo, para echar un vistazo a lo que hay dentro del
archivo `spider.sqlite`:

\VerbatimInput{../code3/twdump.py}

Este programa simplemente abre la base de datos y selecciona todas las
columnas de todas las filas de la tabla `Twitter`, luego se mueve a través
de las filas e imprime en pantalla su contenido.

Si ejecutamos este programa después de la primera ejecución de nuestra araña
de Twitter, la salida que mostrará será similar a esta:

~~~~
('opencontent', 0, 1)
('lhawthorn', 0, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
20 filas.
~~~~

Vemos una fila para cada nombre, que aún no hemos recuperado los datos de
ninguno de esos nombres, y que todo el mundo en la base de datos tiene un
amigo.

En este momento la base de datos muestra la recuperación de los amigos
de nuestra primera cuenta de Twitter (*drchuck*). Podemos ejecutar de nuevo
el programa y pedirle que recupere los amigos de la siguiente cuenta "sin
procesar", simplemente pulsando intro en vez de escribir el nombre de una
cuenta:

~~~~
Ingresa una cuenta de Twitter, o salir:
Recuperando http://api.twitter.com/1.1/friends ...
Cuentas nuevas= 18  ya visitadas= 2
Ingresa una cuenta de Twitter, o salir:
Recuperando http://api.twitter.com/1.1/friends ...
Cuentas nuevas= 17  ya visitadas= 3
Ingresa una cuenta de Twitter, o salir: salir
~~~~

Como hemos pulsado intro (es decir, no hemos especificado otra cuenta de Twitter),
se ha ejecutado el código siguiente:

~~~~ {.python}
if ( len(cuenta) < 1 ) :
    cur.execute('SELECT nombre FROM Twitter WHERE recuperado = 0 LIMIT 1')
    try:
        cuenta = cur.fetchone()[0]
    except:
        print('No se han encontrado cuentas de Twitter por recuperar')
        continue
~~~~

Usamos la sentencia de SQL `SELECT` para obtener el nombre del primer usuario
(`LIMIT 1`) que aún tiene su valor de "hemos recuperado ya este usuario" a cero.
También usamos el patrón `fetchone()[0]` en un bloque try/except para extraer
el "nombre a mostrar" (`screen_name`) de los datos recuperados, o bien mostrar
un mensaje de error y volver al principio.

Si hemos obtenido con éxito el nombre de una cuenta que aún no había sido
procesada, recuperamos sus datos de este modo:

~~~~ {.python}
url=twurl.augment(TWITTER_URL,{'screen_name': cuenta,'count': '20'})
print('Recuperando', url)
conexion = urllib.urlopen(url)
datos = conexion.read()
js = json.loads(datos)

cur.execute('UPDATE Twitter SET recuperado=1 WHERE nombre = ?',(cuenta, ))
~~~~

Una vez recuperados correctamente los datos, usamos la sentencia `UPDATE`
para poner la columna `recuperado` a 1, lo que indica que hemos terminado
la extracción de amigos de esa cuenta. Esto impide que recuperemos los
mismos datos una y otra vez, y nos permite ir avanzando a través de la red
de amigos de Twitter.

Si ejecutamos el programa de amigos y pulsamos intro dos veces para recuperar
los amigos del siguiente amigo no visitado, y luego ejecutamos de nuevo el
programa de volcado de datos, nos mostrará la salida siguiente:

~~~~
('opencontent', 1, 1)
('lhawthorn', 1, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
('cnxorg', 0, 2)
('knoop', 0, 1)
('kthanos', 0, 2)
('LectureTools', 0, 1)
...
55 filas.
~~~~

Podemos ver que se han guardado correctamente las visitas que hemos realizado
a `lhawthorn` y `opencontent`. Además, las cuentas `cnxorg` y `kthanos`
ya tienen dos seguidores. Puesto que hemos recuperado los amigos de tres
personas (`drchuck`, `opencontent`, y `lhawthorn`), la tabla contiene 55
filas de amigos por recuperar.

Cada vez que ejecutamos el programa y pulsamos intro, se elegirá la siguiente
cuenta no visitada (es decir, ahora la siguiente cuenta sería `steve_coppin`),
recuperará sus amigos, los marcará como recuperados y, para cada uno de los
amigos de `steve_coppin`, o bien lo añadirá al final de la base de datos, o
bien actualizará su contador de amigos si ya estaba en la base de datos.

Como todos los datos del programa están almacenados en el disco en una base
de datos, la actividad de rastreo puede ser suspendida y reanudada tantas
veces como se desee, sin que se produzca ninguna pérdida de datos.

Basic data modeling
-------------------

The real power of a relational database is when we create multiple
tables and make links between those tables. The act of deciding how to
break up your application data into multiple tables and establishing the
relationships between the tables is called *data
modeling*. The design document that shows the tables and their
relationships is called a *data model*.

Data modeling is a relatively sophisticated skill and we will only
introduce the most basic concepts of relational data modeling in this
section. For more detail on data modeling you can start with:

<http://en.wikipedia.org/wiki/Relational_model>

Let's say for our Twitter spider application, instead of just counting a
person's friends, we wanted to keep a list of all of the incoming
relationships so we could find a list of everyone who is following a
particular account.

Since everyone will potentially have many accounts that follow them, we
cannot simply add a single column to our `Twitter` table. So
we create a new table that keeps track of pairs of friends. The
following is a simple way of making such a table:

~~~~ {.sql}
CREATE TABLE Pals (from_friend TEXT, to_friend TEXT)
~~~~

Each time we encounter a person who `drchuck` is following,
we would insert a row of the form:

~~~~ {.sql}
INSERT INTO Pals (from_friend,to_friend) VALUES ('drchuck', 'lhawthorn')
~~~~

As we are processing the 20 friends from the `drchuck`
Twitter feed, we will insert 20 records with "drchuck" as the first
parameter so we will end up duplicating the string many times in the
database.

This duplication of string data violates one of the best practices for
*database normalization* which basically states that we
should never put the same string data in the database more than once. If
we need the data more than once, we create a numeric
*key* for the data and reference the actual data using
this key.

In practical terms, a string takes up a lot more space than an integer
on the disk and in the memory of our computer, and takes more processor
time to compare and sort. If we only have a few hundred entries, the
storage and processor time hardly matters. But if we have a million
people in our database and a possibility of 100 million friend links, it
is important to be able to scan data as quickly as possible.

We will store our Twitter accounts in a table named `People`
instead of the `Twitter` table used in the previous example.
The `People` table has an additional column to store the
numeric key associated with the row for this Twitter user. SQLite has a
feature that automatically adds the key value for any row we insert into
a table using a special type of data column (`INTEGER PRIMARY
KEY`).

We can create the `People` table with this additional
`id` column as follows:

~~~~ {.sql}
CREATE TABLE People
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)
~~~~

Notice that we are no longer maintaining a friend count in each row of
the `People` table. When we select `INTEGER PRIMARY
KEY` as the type of our `id` column, we are indicating
that we would like SQLite to manage this column and assign a unique
numeric key to each row we insert automatically. We also add the keyword
`UNIQUE` to indicate that we will not allow SQLite to insert
two rows with the same value for `name`.

Now instead of creating the table `Pals` above, we create a
table called `Follows` with two integer columns `from_id` and
`to_id` and a constraint on the table that the *combination* of
`from_id` and `to_id` must be unique in this table (i.e., we cannot
insert duplicate rows) in our database.

~~~~ {.sql}
CREATE TABLE Follows
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id) )
~~~~

When we add `UNIQUE` clauses to our tables, we are
communicating a set of rules that we are asking the database to enforce
when we attempt to insert records. We are creating these rules as a
convenience in our programs, as we will see in a moment. The rules both
keep us from making mistakes and make it simpler to write some of our
code.

In essence, in creating this `Follows` table, we are
modelling a "relationship" where one person "follows" someone else and
representing it with a pair of numbers indicating that (a) the people
are connected and (b) the direction of the relationship.

![Relationships Between Tables](height=3.5in@figs2/twitter)

Programming with multiple tables
--------------------------------

We will now redo the Twitter spider program using two tables, the
primary keys, and the key references as described above. Here is the
code for the new version of the program:

\VerbatimInput{../code3/twfriends.py}

This program is starting to get a bit complicated, but it illustrates
the patterns that we need to use when we are using integer keys to link
tables. The basic patterns are:

1.  Create tables with primary keys and constraints.

2.  When we have a logical key for a person (i.e., account name) and we
    need the `id` value for the person, depending on whether
    or not the person is already in the `People` table we
    either need to: (1) look up the person in the `People`
    table and retrieve the `id` value for the person or (2)
    add the person to the `People` table and get the
    `id` value for the newly added row.

3.  Insert the row that captures the "follows" relationship.

We will cover each of these in turn.

### Constraints in database tables

As we design our table structures, we can tell the database system that
we would like it to enforce a few rules on us. These rules help us from
making mistakes and introducing incorrect data into out tables. When we
create our tables:

~~~~ {.python}
cur.execute('''CREATE TABLE IF NOT EXISTS People
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)''')
cur.execute('''CREATE TABLE IF NOT EXISTS Follows
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id))''')
~~~~

We indicate that the `name` column in the `People`
table must be `UNIQUE`. We also indicate that the combination
of the two numbers in each row of the `Follows` table must be
unique. These constraints keep us from making mistakes such as adding
the same relationship more than once.

We can take advantage of these constraints in the following code:

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO People (name, retrieved)
    VALUES ( ?, 0)''', ( friend, ) )
~~~~

We add the `OR IGNORE` clause to our `INSERT`
statement to indicate that if this particular `INSERT` would
cause a violation of the "`name` must be unique" rule, the
database system is allowed to ignore the `INSERT`. We are
using the database constraint as a safety net to make sure we don't
inadvertently do something incorrect.

Similarly, the following code ensures that we don't add the exact same
`Follows` relationship twice.

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO Follows
    (from_id, to_id) VALUES (?, ?)''', (id, friend_id) )
~~~~

Again, we simply tell the database to ignore our attempted
`INSERT` if it would violate the uniqueness constraint that
we specified for the `Follows` rows.

### Retrieve and/or insert a record

When we prompt the user for a Twitter account, if the account exists, we
must look up its `id` value. If the account does not yet
exist in the `People` table, we must insert the record and
get the `id` value from the inserted row.

This is a very common pattern and is done twice in the program above.
This code shows how we look up the `id` for a friend's
account when we have extracted a `screen_name` from a `user`
node in the retrieved Twitter JSON.

Since over time it will be increasingly likely that the account will
already be in the database, we first check to see if the
`People` record exists using a `SELECT` statement.

If all goes well^[In general, when a sentence starts with "if all goes well" you
will find that the code needs to use try/except.] inside 
the `try` section, we retrieve
the record using `fetchone()` and then retrieve the first
(and only) element of the returned tuple and store it in `friend_id`.

If the `SELECT` fails, the `fetchone()[0]` code
will fail and control will transfer into the `except`
section.

~~~~ {.python}
    friend = u['screen_name']
    cur.execute('SELECT id FROM People WHERE name = ? LIMIT 1',
        (friend, ) )
    try:
        friend_id = cur.fetchone()[0]
        countold = countold + 1
    except:
        cur.execute('''INSERT OR IGNORE INTO People (name, retrieved)
            VALUES ( ?, 0)''', ( friend, ) )
        conn.commit()
        if cur.rowcount != 1 :
            print('Error inserting account:',friend)
            continue
        friend_id = cur.lastrowid
        countnew = countnew + 1
~~~~

If we end up in the `except` code, it simply means that the
row was not found, so we must insert the row. We use `INSERT OR
IGNORE` just to avoid errors and then call `commit()`
to force the database to really be updated. After the write is done, we
can check the `cur.rowcount` to see how many rows were
affected. Since we are attempting to insert a single row, if the number
of affected rows is something other than 1, it is an error.

If the `INSERT` is successful, we can look at
`cur.lastrowid` to find out what value the database assigned
to the `id` column in our newly created row.

### Storing the friend relationship

Once we know the key value for both the Twitter user and the friend in
the JSON, it is a simple matter to insert the two numbers into the
`Follows` table with the following code:

~~~~ {.python}
cur.execute('INSERT OR IGNORE INTO Follows (from_id, to_id) VALUES (?, ?)',
    (id, friend_id) )
~~~~

Notice that we let the database take care of keeping us from
"double-inserting" a relationship by creating the table with a
uniqueness constraint and then adding `OR IGNORE` to our
`INSERT` statement.

Here is a sample execution of this program:

~~~~
Enter a Twitter account, or quit:
No unretrieved Twitter accounts found
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
~~~~

We started with the `drchuck` account and then let the
program automatically pick the next two accounts to retrieve and add to
our database.

The following is the first few rows in the `People` and
`Follows` tables after this run is completed:

~~~~
People:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
~~~~

You can see the `id`, `name`, and
`visited` fields in the `People` table and you see
the numbers of both ends of the relationship in the `Follows`
table. In the `People` table, we can see that the first three
people have been visited and their data has been retrieved. The data in
the `Follows` table indicates that `drchuck` (user
1) is a friend to all of the people shown in the first five rows. This
makes sense because the first data we retrieved and stored was the
Twitter friends of `drchuck`. If you were to print more rows
from the `Follows` table, you would see the friends of users
2 and 3 as well.

Three kinds of keys
-------------------

Now that we have started building a data model putting our data into
multiple linked tables and linking the rows in those tables using
*keys*, we need to look at some terminology around keys.
There are generally three kinds of keys used in a database model.

-   A *logical key* is a key that the "real world" might
    use to look up a row. In our example data model, the
    `name` field is a logical key. It is the screen name for
    the user and we indeed look up a user's row several times in the
    program using the `name` field. You will often find that
    it makes sense to add a `UNIQUE` constraint to a logical
    key. Since the logical key is how we look up a row from the outside
    world, it makes little sense to allow multiple rows with the same
    value in the table.

-   A *primary key* is usually a number that is assigned
    automatically by the database. It generally has no meaning outside
    the program and is only used to link rows from different tables
    together. When we want to look up a row in a table, usually
    searching for the row using the primary key is the fastest way to
    find the row. Since primary keys are integer numbers, they take up
    very little storage and can be compared or sorted very quickly. In
    our data model, the `id` field is an example of a primary
    key.

-   A *foreign key* is usually a number that points to
    the primary key of an associated row in a different table. An
    example of a foreign key in our data model is the `from_id`.

We are using a naming convention of always calling the primary key field
name `id` and appending the suffix `_id` to any field name
that is a foreign key.

Using JOIN to retrieve data
---------------------------

Now that we have followed the rules of database normalization and have
data separated into two tables, linked together using primary and
foreign keys, we need to be able to build a `SELECT` that
reassembles the data across the tables.

SQL uses the `JOIN` clause to reconnect these tables. In the
`JOIN` clause you specify the fields that are used to
reconnect the rows between the tables.

The following is an example of a `SELECT` with a
`JOIN` clause:

~~~~ {.sql}
SELECT * FROM Follows JOIN People
    ON Follows.from_id = People.id WHERE People.id = 1
~~~~

The `JOIN` clause indicates that the fields we are selecting
cross both the `Follows` and `People` tables. The
`ON` clause indicates how the two tables are to be joined:
Take the rows from `Follows` and append the row from
`People` where the field `from_id` in `Follows` is
the same the `id` value in the `People` table.

![Connecting Tables Using JOIN](height=3.5in@figs2/join)

The result of the JOIN is to create extra-long "metarows" which have
both the fields from `People` and the matching fields from
`Follows`. Where there is more than one match between the
`id` field from `People` and the `from_id` from
`People`, then JOIN creates a metarow for *each* of the
matching pairs of rows, duplicating data as needed.

The following code demonstrates the data that we will have in the
database after the multi-table Twitter spider program (above) has been
run several times.

\VerbatimInput{../code3/twjoin.py}

In this program, we first dump out the `People` and
`Follows` and then dump out a subset of the data in the
tables joined together.

Here is the output of the program:

~~~~
python twjoin.py
People:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
Connections for id=2:
(2, 1, 1, 'drchuck', 1)
(2, 28, 28, 'cnxorg', 0)
(2, 30, 30, 'kthanos', 0)
(2, 102, 102, 'SomethingGirl', 0)
(2, 103, 103, 'ja_Pac', 0)
20 rows.
~~~~

You see the columns from the `People` and
`Follows` tables and the last set of rows is the result of
the `SELECT` with the `JOIN` clause.

In the last select, we are looking for accounts that are friends of
"opencontent" (i.e., `People.id=2`).

In each of the "metarows" in the last select, the first two columns are
from the `Follows` table followed by columns three through
five from the `People` table. You can also see that the
second column (`Follows.to_id`) matches the third column
(`People.id`) in each of the joined-up "metarows".

Summary
-------

This chapter has covered a lot of ground to give you an overview of the
basics of using a database in Python. It is more complicated to write
the code to use a database to store data than Python dictionaries or
flat files so there is little reason to use a database unless your
application truly needs the capabilities of a database. The situations
where a database can be quite useful are: (1) when your application
needs to make small many random updates within a large data set, (2)
when your data is so large it cannot fit in a dictionary and you need to
look up information repeatedly, or (3) when you have a long-running
process that you want to be able to stop and restart and retain the data
from one run to the next.

You can build a simple database with a single table to suit many
application needs, but most problems will require several tables and
links/relationships between rows in different tables. When you start
making links between tables, it is important to do some thoughtful
design and follow the rules of database normalization to make the best
use of the database's capabilities. Since the primary motivation for
using a database is that you have a large amount of data to deal with,
it is important to model your data efficiently so your programs run as
fast as possible.

Debugging
---------

One common pattern when you are developing a Python program to connect
to an SQLite database will be to run a Python program and check the
results using the Database Browser for SQLite. The browser allows you to
quickly check to see if your program is working properly.

You must be careful because SQLite takes care to keep two programs from
changing the same data at the same time. For example, if you open a
database in the browser and make a change to the database and have not
yet pressed the "save" button in the browser, the browser "locks" the
database file and keeps any other program from accessing the file. In
particular, your Python program will not be able to access the file if
it is locked.

So a solution is to make sure to either close the database browser or
use the *File* menu to close the database in the browser
before you attempt to access the database from Python to avoid the
problem of your Python code failing because the database is locked.

Glossary
--------

attribute
:   One of the values within a tuple. More commonly called a "column" or
    "field".
\index{attribute}

constraint
:   When we tell the database to enforce a rule on a field or a row in a
    table. A common constraint is to insist that there can be no
    duplicate values in a particular field (i.e., all the values must be
    unique).
\index{constraint}

cursor
:   A cursor allows you to execute SQL commands in a database and
    retrieve data from the database. A cursor is similar to a socket or
    file handle for network connections and files, respectively.
\index{cursor}

database browser
:   A piece of software that allows you to directly connect to a
    database and manipulate the database directly without writing a
    program.
\index{database browser}

foreign key
:   A numeric key that points to the primary key of a row in another
    table. Foreign keys establish relationships between rows stored in
    different tables.
\index{foreign key}

index
:   Additional data that the database software maintains as rows and
    inserts into a table to make lookups very fast.
\index{index}
\index{}

logical key
:   A key that the "outside world" uses to look up a particular row. For
    example in a table of user accounts, a person's email address might
    be a good candidate as the logical key for the user's data.
\index{logical key}

normalization
:   Designing a data model so that no data is replicated. We store each
    item of data at one place in the database and reference it elsewhere
    using a foreign key.
\index{normalization}
\index{database normalization}

primary key
:   A numeric key assigned to each row that is used to refer to one row
    in a table from another table. Often the database is configured to
    automatically assign primary keys as rows are inserted.
\index{primary key}

relation
:   An area within a database that contains tuples and attributes. More
    typically called a "table".
\index{relation}

tuple
:   A single entry in a database table that is a set of attributes. More
    typically called "row".

\index{tuple}

